use super::{ax_err, ActyxOSCode, ActyxOSError, ActyxOSResult};
use crate::wrapping_subscriber::ConvertEvent;

use actyxos_sdk::NodeId;
use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use std::{
    collections::BTreeMap,
    convert::{TryFrom, TryInto},
    fmt::{self, Write},
};
use tracing::{
    field::{Field, Visit},
    Event,
};
/// Format of the incoming log messages from clients
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
#[serde(rename_all = "camelCase")]
pub struct LogRequest {
    pub log_timestamp: Option<DateTime<Utc>>,
    pub severity: LogSeverity,
    pub message: String,
    pub log_name: String,
    pub additional_data: Option<BTreeMap<String, serde_json::value::Value>>,
    pub labels: Option<BTreeMap<String, String>>,
    pub producer_name: String,
    pub producer_version: String,
}
pub struct MessageVisitor<'a> {
    pub string: &'a mut String,
}

impl<'a> Visit for MessageVisitor<'a> {
    fn record_debug(&mut self, field: &Field, value: &dyn fmt::Debug) {
        if field.name() == "message" {
            write!(self.string, "{:?}; ", value).unwrap();
        }
    }
}

impl ConvertEvent for LogRequest {
    fn convert(ev: &Event<'_>) -> Self {
        let log_timestamp = Some(Utc::now());
        let metadata = ev.metadata();
        let severity = metadata.level().into();
        let mut message = String::from("");
        let mut visitor = MessageVisitor { string: &mut message };
        ev.record(&mut visitor);
        let tag = metadata.target().to_string();

        LogRequest {
            log_timestamp,
            severity,
            message,
            log_name: tag,
            additional_data: None,
            labels: None,
            producer_name: "com.actyx.os".into(),
            producer_version: "2.0.0-dev".into(),
        }
    }
}

impl From<&tracing::Level> for LogSeverity {
    fn from(l: &tracing::Level) -> Self {
        use tracing::Level;
        match *l {
            Level::TRACE => LogSeverity::Trace,
            Level::DEBUG => LogSeverity::Debug,
            Level::INFO => LogSeverity::Info,
            Level::WARN => LogSeverity::Warn,
            Level::ERROR => LogSeverity::Error,
        }
    }
}
#[cfg(target_os = "android")]
impl From<rogcat::record::Level> for LogSeverity {
    fn from(l: rogcat::record::Level) -> Self {
        use rogcat::record::Level;
        match l {
            Level::None | Level::Verbose | Level::Trace => LogSeverity::Trace,
            Level::Debug => LogSeverity::Debug,
            Level::Info => LogSeverity::Info,
            Level::Warn => LogSeverity::Warn,
            Level::Error => LogSeverity::Error,
            Level::Fatal | Level::Assert => LogSeverity::Fatal,
        }
    }
}
#[cfg(target_os = "android")]
impl From<rogcat::record::Record> for LogRequest {
    fn from(r: rogcat::record::Record) -> Self {
        use maplit::btreemap;
        Self {
            // we only get local timestamps in the form of `12-12 10:54:34.891`
            // which makes it very hard to parse correctly, especially as these
            // are generated by Android. Let `logsvcd` generate the timestamps..
            log_timestamp: None,
            severity: r.level.into(),
            message: r.message,
            log_name: r.tag.clone(),
            additional_data: None,
            labels: Some(btreemap! {
                "process".to_string() => r.process,
                "thread".to_string() => r.thread,
                "tag".to_string() => r.tag
            }),
            producer_name: "com.actyx.os.android".to_string(),
            // TODO
            producer_version: "1.0.0".to_string(),
        }
    }
}

/// Format of the outgoing log messages. Like `LogRequest`, but with `node_id` and `node_name`.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
#[serde(rename_all = "camelCase")]
pub struct LogEvent {
    pub sequence_number: u64,
    pub log_timestamp: DateTime<Utc>,
    pub node_id: NodeId,
    pub node_name: String,
    pub severity: LogSeverity,
    pub message: String,
    pub log_name: String,
    pub additional_data: Option<BTreeMap<String, serde_json::value::Value>>,
    pub labels: Option<BTreeMap<String, String>>,
    pub producer_name: String,
    pub producer_version: String,
}
#[derive(Clone, PartialEq, Serialize, Debug, Copy)]
#[serde(rename_all = "UPPERCASE")]
pub enum LogSeverity {
    Trace,
    Debug,
    Info,
    Warn,
    Error,
    Fatal,
}
impl<'de> serde::de::Deserialize<'de> for LogSeverity {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::de::Deserializer<'de>,
    {
        let str = <String>::deserialize(deserializer)?;
        (&*str).try_into().map_err(serde::de::Error::custom)
    }
}
impl TryFrom<&str> for LogSeverity {
    type Error = ActyxOSError;
    fn try_from(other: &str) -> ActyxOSResult<Self> {
        let from = other.to_lowercase();
        let x = match from.as_ref() {
            "trace" => LogSeverity::Trace,
            "debug" => LogSeverity::Debug,
            "info" => LogSeverity::Info,
            "warn" => LogSeverity::Warn,
            "error" => LogSeverity::Error,
            "fatal" => LogSeverity::Fatal,
            _ => {
                return ax_err(
                    ActyxOSCode::ERR_INVALID_INPUT,
                    format!("\"{}\" doesn't match any known log level", from),
                )
            }
        };
        Ok(x)
    }
}
impl Default for LogSeverity {
    fn default() -> Self {
        LogSeverity::Info
    }
}
impl fmt::Display for LogSeverity {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        let name = match *self {
            LogSeverity::Trace => "TRACE",
            LogSeverity::Debug => "DEBUG",
            LogSeverity::Info => "INFO",
            LogSeverity::Warn => "WARN",
            LogSeverity::Error => "ERROR",
            LogSeverity::Fatal => "FATAL",
        };
        write!(f, "{}", name)
    }
}
impl LogSeverity {
    pub fn from_level(level: i64) -> Self {
        match level {
            0 => LogSeverity::Trace,
            1 => LogSeverity::Debug,
            2 => LogSeverity::Info,
            3 => LogSeverity::Warn,
            4 => LogSeverity::Error,
            _ => LogSeverity::Fatal,
        }
    }
    pub fn to_level(self) -> i8 {
        match self {
            LogSeverity::Trace => 0,
            LogSeverity::Debug => 1,
            LogSeverity::Info => 2,
            LogSeverity::Warn => 3,
            LogSeverity::Error => 4,
            LogSeverity::Fatal => 5,
        }
    }
}

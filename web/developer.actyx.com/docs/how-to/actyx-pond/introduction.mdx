---
title: Introduction to Actyx Pond
id: introduction
hide_title: false
hide_table_of_contents: false
sidebar_label: Introduction
keywords: [how-to-guide, pond]
description: How-to-guide for introducing Actyx Pond.
image: /images/defaults/default.svg
---

Writing distributed apps is difficult.
The **Actyx Pond** framework makes it simpler by providing an opinionated set of tools on top of [Actyx](../local-development/install-actyx.mdx).

The idea behind Actyx Pond is that you take your app’s business logic and split it according to responsibilities.
These usually match the physical objects or abstract concepts that your app models and interacts with: temperature sensors, robots, receipts, or text messages.
Each responsibility is packaged as a unit called _a fish_ and all these fishes swim together in _the pond_, exchanging messages and knowledge by emitting and consuming event streams.

You can imagine Actyx Pond as a scaffolding into which you plug your business logic; your logic makes sense of events and aggregates knowledge in its state, while the pond takes care to keep your business logic up to date with the latest information available.
It is a framework for consuming the event streams provided by the Actyx event-focused database, and it helps you make the best use of the fully distributed architecture of Actyx — it simplifies the creation of [Local-First applications](https://www.local-first-cooperation.org).

An application can only fully exploit always-on availability if it acknowledges the constraints that come with this choice.
Your algorithms will make decisions based only on the currently and locally available information: calling a transactional database to achieve strong consistency would prevent the app from functioning while that database is unavailable for any reason.
Actyx Pond therefore makes these constraints explicit and gives you tools for detecting erroneous decisions (caused by incomplete information) and correcting them later.

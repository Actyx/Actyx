---
title: Query events with AQL
id: query-events-with-aql
hide_title: false
hide_table_of_contents: false
---

The Actyx Query Language (AQL) allows you to query, filter, transform, and aggregate events in a structured fashion.
For a quickstart please refer to [the tutorial](../../tutorials/aql.mdx) whereas all details are documented in [the reference](../../reference/aql.mdx).
In this section we take a look at how Actyx helps you access exactly those events you need and why that is important.
As we will see, this has implications on how events should be tagged when they are emitted; best practices for this are discussed in the next section.

## AQL evaluation explained

When you send a query to one of the [API endpoints](../../reference/events-api.mdx) Actyx will — after a syntax check — do two things:
first it will instruct the local event store to retrieve all events matching the `FROM` clause, and second it will create an evaluation engine for the following query steps.
Then, matching events will be streamed into that engine, always completing all steps before continuing with the next event.
Whenever an output emerges from the last query step it is serialised to JSON and sent to your app.

Assuming you model some entities — like TODO items — with a lifecycle we might store events for creating, editing, progress tracking, and completing them.
If you want to get the IDs of all items created within the past month you might do the following:

```sql
FROM 'item' & TIME > 1M ago -- get all item events
FILTER _.type = 'created'   -- skip all but creations
SELECT _.id                 -- pick out the ID
```

Assuming a couple of edits and lots of progress tracking it may well be that the filter step throws away >90% of the work done by the local event store for streaming the events.
This can be avoided by tagging the creation events with an additional tag, so that we can write:

```sql
FROM 'item' & 'created' & TIME > 1M ago
SELECT _.id
```

The performance difference between these can be quite noticeable.
This is doubly relevant when the query isn’t crafted by you but sent indirectly, e.g. via the Actyx Pond library:
in this case the filtering would need to be done inside your `onEvent` function in TypeScript, which wastes not only the work inside the Actyx event store but also the much more costly serialisation and deserialisation of the events on their path towards `onEvent`.

:::info take notice!
Excessive event retrieval is the #1 performance sin in Actyx, comparable to full table scans in relational databases.
Event tagging fulfils the same function as indexing in those databases.
:::

:::info Full reference documentation
Check out our [reference documentation on AQL](../../reference/aql.mdx) for more info on expressions and data transformations!
:::

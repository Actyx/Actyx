---
title: 'Swarm Workflow Pt. 2 - Testing'
id: js-cooperative-task-2-test
keywords: [tutorial]
image: /images/defaults/default.svg
---

import { ExpandableDiagram, ExpandableDiagramUtils } from "/src/components/custom-codeblocks/expandable-diagram"

<!-- markdownlint-disable MD038 MD014 -->

:::info

This tutorial immediately follows and uses the code of the [previous tutorial](./js-cooperative-task.mdx).
It is recommended to complete that before beginning this tutorial.

:::


[The previous tutorial](./js-cooperative-task.mdx) visits the idea where a swarm (i.e. the robot and the pump) works on one sequential workflow (docking, drawing water, undocking).
For the problem, we built a protocol based on [`machine-runner`](https://www.npmjs.com/package/@actyx/machine-runner) and `Actyx`.
The protocol governs the sequence of tasks in terms of `states` (alongside the `commands` and the `reactions`) and `events` while at the same time facilitating the agents the means to communicate according to the workflow.

In this tutorial, we will explore [`machine-check`](https://www.npmjs.com/package/@actyx/machine-check), a library to test the completeness of a `machine-runner`-based protocol.

## The World Runs When You Do Your Part

`machine-check` tests aspects within `machine-runner`'s scope.
It checks whether a protocol facilitates an agent (by allowing access to state and exposing commands) so that it can communicate the correct message when required.
The most important criteria that `machine-check` seeks to prove in a protocol are:

- For every state, there must be at least one role that can emit an event that moves the workflow forward;
- An event can only trigger at most one transition (ensuring unambiguous event semantics);


:::caution caveat

A workflow completes only when every agent does its part of its work.
However, `machine-check` only proves the facilities provided by `machine-runner` protocol and not how an agent interacts with the protocol.

An accompanying test must also be written to make sure that the agent correctly uses the protocol.

:::

Without further ado, let us proceed to illustrate those concepts with practice.

## Preparation

:::info No use of testing framework

NodeJS-provided [`assert`](https://nodejs.org/api/assert.html) module will be used for the test code.

`@actyx/machine-check` is compatible with any testing framework (e.g. mocha, jest, etc)

:::

1. Create a new test file `src/index.test.ts`

2. Then, add this script to test

```json title="package.json"
{
  "scripts": {
    // rest of the script,
    "test": "npm run compile && node dist/index.test.js"
  }
}
```

3. Now you can use this command to run the test:

```bash
$ npm run test
```

4. Install [`machine-check`](https://www.npmjs.com/package/@actyx/machine-check).

```bash
$ npm install @actyx/machine-check
```

## Testing The Protocol

Import what we need for the test:
NodeJS's assert, `machine-check` utilities, and the very object we will test the protocol.

```typescript title="src/index.test.ts"
import {
  SwarmProtocolType,
  checkProjection,
  checkSwarmProtocol,
} from "@actyx/machine-check";
import { WaterPump, WateringRobot, protocol } from "./machines";
import * as assert from "node:assert"

const { ProtocolEvents } = protocol
```

The previous tutorial illustrates the workflow of a swarm of two (one robot and one water pump) executing a sequential task of docking, drawing water, and undocking. We have an [interaction design](/docs/tutorials/js-cooperative-task#interaction-design) written as a state diagram. 

export const stateDiagram = `
Initial --> Docking: "DockAvailable"\\nby pump
Docking --> DrawingWater: "RobotIsDocked"\\nby robot
DrawingWater --> Undocking: "WaterSupplied"\\nby pump
Undocking --> Done: "RobotIsUndocked"\\nby robot"
`.trim();

<ExpandableDiagram 
  presentedCode={stateDiagram.replace(/\\n/gi, " ")}
  code={
`
stateDiagram-v2
direction LR
[*] --> Initial
${ExpandableDiagramUtils.indent(stateDiagram, 2)}
`.trim()}
/>

This is a useful starting point. We can convert the above diagram to a data type that's understood by `machine-check`.

```typescript title="index.test.ts"

const swarmProtocol: SwarmProtocolType = {
  initial: "Initial",
  transitions: [
    // 1. Initial + ("DockAvailable" by pump) => Docking
    { source: "Initial", target: "Docking", label: {
        cmd: "dockAvailable",
        role: "pump",
        logType: [ProtocolEvents.DockAvailable.type],
      },
    },
    // 2. Docking + ("RobotIsDocked" by robot) => DrawingWater
    { source: "Docking", target: "DrawingWater", label: {
        cmd: "docked",
        role: "robot",
        logType: [ProtocolEvents.RobotIsDocked.type],
      },
    },
    // 3. DrawingWater + ("WaterSupplied" by pump) => Undocking
    { source: "DrawingWater", target: "Undocking", label: {
        cmd: "waterSupplied",
        role: "pump",
        logType: [ProtocolEvents.WaterSupplied.type],
      },
    },
    // 4. Undocking + ("RobotIsUndocked") => Done
    { source: "Undocking", target: "Done", label: {
        cmd: "Done",
        role: "robot",
        logType: [ProtocolEvents.RobotIsUndocked.type],
      },
    },
  ],
};

```

Pay attention to what transition maps to the resulting object, for example in the first transition.

- `Initial` maps as a `source`
- `DockAvailable` maps as `logType`
- `pump` maps as a `role`
- `Docking` maps as a `target`
- Finally, `cmd` maps to the command name in the implemented `MachineProtocol` (see previous tutorial).

Next, extract the data from the role protocol.
The data contain the role's state-transition graph.

```typescript title="src/index.test.ts"
const waterPumpData = WaterPump.machine.createJSONForAnalysis(
  WaterPump.ClearingDock
);

const wateringRobotData = WateringRobot.machine.createJSONForAnalysis(
  WateringRobot.WaitingForAvailableDock
);

const subscriptions = {
  pump: waterPumpData.subscriptions,
  robot: wateringRobotData.subscriptions,
};
```

Finally, we now have the data we need, the intended workflow (SwarmProtocolType), and the state-transition graph of each role.
Now to verify these data, we can:

```typescript title="src/index.test.ts"
assert.deepStrictEqual(checkSwarmProtocol(swarmProtocol, subscriptions), {
  type: "OK"
}, "protocol is not well-formed")

assert.deepStrictEqual(checkProjection(swarmProtocol, subscriptions, "robot", wateringRobotData), {
  type: "OK"
}, "robot is not well-formed")

assert.deepStrictEqual(checkProjection(swarmProtocol, subscriptions, "pump", waterPumpData), {
  type: "OK"
}, "pump is not well-formed")
```

### Test Explanation

(TODO: I think there's a lot to be explained)

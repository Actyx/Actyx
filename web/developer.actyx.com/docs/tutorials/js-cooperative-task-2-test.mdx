---
title: 'Cooperative Task Pt. 2 - Testing'
id: js-cooperative-task-2-test
keywords: [tutorial]
image: /images/defaults/default.svg
---

:::info

This tutorial immediately follows and uses the code of the [previous tutorial](./js-cooperative-task.mdx).
It is recommended to complete that before beginning this tutorial.

:::

## The World Runs When You Do Your Part

In the [previous tutorial](./js-cooperative-task.mdx), we visited the idea where a swarm, a collection of agents, works on one sequential workflow.
We built a protocol which governs the swarm's communication.
The protocol is built on top of [`machine-runner`](https://www.npmjs.com/package/@actyx/machine-runner) and `Actyx`.

In this tutorial, we will explore [`machine-check`](https://www.npmjs.com/package/@actyx/machine-check) to prove that a `machine-runner`-based protocol fully facilitate all involved agents so that the workflow can complete.

The previous tutorial illustrate the workflow of a swarm of two (one robot and one water pump) executing a sequential task of docking, drawing water, and undocking, detailed as follows:

1. the pump signals that the dock is available;
1. the robot docks, then signals the pump that it is ready for water;
1. the pump draws water, and signals on completion;
1. the robot leaves, then signals that it has sucessfully undocked and distanced.

`machine-runner` protocol enables an agent in the swarm to know the workflow's state, and for each state, the capability to send a relevant signal to the swarm (as Actyx-replicated events).
For that, the library breaks down the problem into these concepts:

- `event` is a message replicated throughtout the swarm (e.g. "robot-docked")
- `role` is a role of an agent relative to the swarm (e.g. "robot", or "pump")
- `state` is a state of the workflow from the perspective of a role (e.g. "robot-is-docking", the "pump-waits-robot-to-dock")
- `transition` is how a state changes to another as a response to an event chain (e.g. "pump-waits-robot-to-dock" turns into "pump-is-drawing-water" in the event of "robot-docked")
- `command` is a role's conditionally-available and optionally-executable action that yields an event chain (e.g. "robot-docked" can be emitted by "robot" during "robot-is-docking")

A `machine-runner` protocol can facilitate the workflow's completion if:

- for every state, at least one role must emit a meaningful command (one that emits events that move the workflow forward)
- an event can only trigger at most one transition, to ensure unambiguous effect to the workflow
- every role implemention must match the role's part in the overall interaction of the workflow

The above statements are the criteria `machine-check` library checks in a `machine-runner`-based protocol.

Without further ado, let us proceed to illustrating those concepts with a practice.

## Test Setup

Install the packages required for running the tests.

```bash
$ npm install jest ts-jest @types/jest @actyx/machine-check
```

Create the configuration file for `jest` at `jest.config.ts`.

```typescript title="jest.config.ts"
import type { JestConfigWithTsJest } from 'ts-jest'

const jestConfig: JestConfigWithTsJest = {
  preset: 'ts-jest',
  testEnvironment: 'node',
}
export default jestConfig
```

Lastly, the add this script in `package.json`.

```json title="package.json"
{
  "scripts": {
    // rest of the script,
    "test": "jest"
  }
}
```

Now you can use this command to run the test:

```bash
$ npm run test
```

## Test Script

First, create file in `src/index.test.ts`.

Within that file, import the essential objects from `machine-check` and the protocol file from the previous tutorial.

```typescript title="src/index.test.ts"
import {
  SwarmProtocolType,
  checkProjection,
  checkSwarmProtocol,
} from "@actyx/machine-check";
import { describe } from "@jest/globals";
import { WaterPump, WateringRobot, protocol } from "./machines";

const { ProtocolEvents } = protocol
```

Let us revisit the [interaction design from the previous tutorial](/docs/tutorials/js-cooperative-task#interaction-design).
What we have is an interlaced sequence of `states` and `events`, a useful starting point.

```text
1. robot waits & pump ensures the dock is clear
2. pump signals: "dock available"

3. robot docks & pump waits
4. robot signals: "docking successful"

5. robot waits & pump supplies water
6. pump signals: water supplied

7. robot undocks & pump waits
8. robot signals: undock successful

9. done
```

For this guide, we need to reformat the sequence into the workflow transitions.
Starting with the first one:

```text
1. Initial + ("DockAvailable" by pump) => Docking
```

The above line means: state "Initial", applied with event "DockAvailable" produced by the pump, will transition to "Docking".
The pump perceives "Initial" as a state when it should clear the dock;
the robot perceives "Initial" as a state when it should wait for the pump to say it's safe to dock;
but what's important is that both agents acknowledge the workflow state.

Continuing exercise and we will arrive at this:

```text
1. Initial + ("DockAvailable" by pump) => Docking
2. Docking + ("RobotIsDocked" by robot) => DockedAndWaitingForWater
3. DockedAndWaitingForWater + ("WaterSupplied" by pump) => WaterDrawn
4. WaterDrawn + ("RobotIsUndocked") => Undocked
```

Now we will convert the transitions above to data that's understood by `machine-check`.

```typescript title="index.test.ts"

const swarmProtocol: SwarmProtocolType = {
  initial: "Initial",
  transitions: [
    // 1. Initial + ("DockAvailable" by pump) => Docking
    { source: "Initial", target: "Docking", label: {
        cmd: "dockAvailable",
        role: "pump",
        logType: [ProtocolEvents.DockAvailable.type],
      },
    },
    // 2. Docking + ("RobotIsDocked" by robot) => DockedAndWaitingForWater
    { source: "Docking", target: "DockedAndWaitingForWater", label: {
        cmd: "docked",
        role: "robot",
        logType: [ProtocolEvents.RobotIsDocked.type],
      },
    },
    // 3. DockedAndWaitingForWater + ("WaterSupplied" by pump) => WaterDrawn
    { source: "DockedAndWaitingForWater", target: "WaterDrawn", label: {
        cmd: "waterSupplied",
        role: "pump",
        logType: [ProtocolEvents.WaterSupplied.type],
      },
    },
    // 4. WaterDrawn + ("RobotIsUndocked") => Undocked
    { source: "WaterDrawn", target: "Undocked", label: {
        cmd: "undocked",
        role: "robot",
        logType: [ProtocolEvents.RobotIsUndocked.type],
      },
    },
  ],
};

```

Pay attention what transition maps to the resulting object, for example in the first transition.

- `Initial` maps as a `source`
- `DockAvailable` maps as `logType`
- `pump` maps as a `role`
- `Docking` maps as a `target`
- Finally, `cmd` maps to the command name in the implemented `MachineProtocol` (see previous tutorial).

Next, extract the data from the role protocol.
The data contain the role's state-transition graph.

```typescript title="src/index.test.ts"
const waterPumpData = WaterPump.machine.createJSONForAnalysis(
  WaterPump._1_Initial
);

const wateringRobotData = WateringRobot.machine.createJSONForAnalysis(
  WateringRobot._1_WaitingForDock
);

const subscriptions = {
  pump: waterPumpData.subscriptions,
  robot: wateringRobotData.subscriptions,
};
```

Finally, we now have the data we need, the intended workflow (SwarmProtocolType) and the state-transition graph of each role.
Now to verify these data, we can:

```typescript title="src/index.test.ts"
describe("protocol", () => {
  it("is well-formed", () => {
    expect(checkSwarmProtocol(swarmProtocol, subscriptions)).toEqual({
      type: "OK",
    });
  });
});

describe("robot", () => {
  it("is well-formed", () => {
    expect(
      checkProjection(swarmProtocol, subscriptions, "robot", wateringRobotData)
    ).toEqual({
      type: "OK",
    });
  })
});

describe("pump", () => {
  it("is well-formed", () => {
    expect(
      checkProjection(swarmProtocol, subscriptions, "pump", waterPumpData)
    ).toEqual({
      type: "OK",
    });
  })
})
```

### Explaining the scripts

(TODO: I think there's a lot to be explained)
---
title: Performance and limits
id: performance-and-limits
hide_title: false
hide_table_of_contents: false
image: /images/defaults/default.svg
---

This conceptual guide explains the limitations of ActyxOS in real-world factory solutions with regard to:

- [Latency](#latency)
- [Max. number of nodes](#max-number-of-nodes)
- [Required disk space of devices](#required-disk-space)
- [Performance](#performance)

## Latency

Event communication latencies are extremely hard to predict.
Hundreds of things play into this, from the hardware of your edge devices to a forklift passing in front of a wireless access point.
The following statements hold under typical conditions most of the time:

- event delivery latency is below 200ms unless you are pushing performance limits (see below)
- in general, ActyxOS has lower latency volatility than most centralized systems

Keep in mind that ActyxOS does not offer deterministic real-time services; you should use a PLC for such cases.

:::tip Get in touch
As a developer you can always build apps that will bring any system to its knees.
If you follow best-practices you should not face any issues.
If you do, please [get in touch with us and the Actyx community](https://community.actyx.com/)—we love optimizing!
:::

## Max. number of nodes

The amount of devices you can reliably run in a single ActyxOS swarm depends on a large number of factors, including the local-area network setup, the devices themselves, and the apps running on them.
With typical rugged tablets (CPU from around 2013) and Raspberry Pi 3 gateways, 100 devices should by themselves not pose a problem.
If you start pushing performance limits (see below) then this number can be significantly lower, depending on the event data rate and the computational complexity of your business logic.

:::tip You need to connect thousands of edge devices?
Please [get in touch with us and the Actyx community](https://community.actyx.com/): we would love to hear about your use-case and figure out how to make it work with ActyxOS.
:::

## Required disk space of devices

ActyxOS is a completely decentralized system dependent on the disk space of every single edge device.
At runtime different types of data are generated and stored throughout the ActyxOS swarm.
Current versions of ActyxOS store every event on all devices of the same swarm; in the future we will add partial replication so that you can include devices with smaller disk that won’t replicate all the data.

|Type|Size|Deletable?|
|----|----|----------|
|Event|max. 4KB|**No**, events have infinite lifespan unless you reset the swarm.|
|Log|max. 4KB| Yes, the ActyxOS Console Service clears logs automatically when disk space is needed.|

As logs are cleared automatically, they will not lead to running out of disk space. The point at which you will run out of disk space because of events depends on their number and size. 100 million events with an average size of 0.2 KB will require a maximum of 20 GB of disk space.

Currently, the only solution to running out of disk space because of events is either clearing events from your swarm or increasing the disk space of your edge devices. We are already working on a functionality that lets you configure whether events can be forgotten after a certain amount of time, or before you run out of disk space.

:::tip Your solution will produce 100s of millions of events?
Please [get in touch with us and the Actyx community](https://community.actyx.com/): we would love to hear about your use-case and figure out how to make it work with ActyxOS.
:::

## Performance

The limits given above are formulated under the assumption that the processing of events by business logic does not use significant resources.
While there are vast differences between languages, runtimes, CPU architectures, and your choices of business logic algorithms and data structures, this section gives some guidance based on our experience.

### Application and Fish startup time

Bringing a Fish up to date for the first time in an application run (we say “hydrating” or “waking up” the Fish) requires a starting point (which can be a semantic or state snapshot) and the application of all following events.
If a Fish requires a large number of events for starting up then it will take a correspondingly long time until the first state is available and the first command can be processed — the startup time is proportional to the number of events selected by the subscription (see below for the effect of snapshots).

Our recommendation is to structure your fishes such that each requires less than 1'000 events.
This means that fishes are best used to model process workflows (which rarely have more than 1'000 steps).
Fishes are not ideal for accumulating statistical data over long time periods; a better solution for that use-case is to export the events into a time-series database.

### The effect of semantic snapshots

Semantics snapshots effectively truncate the event history: everything before the recognised snapshot event is ignored.
This still means that the snapshot event needs to be found (by searching backwards from the current end of the event log) and that all younger events need to be applied.

Semantic snapshots help a lot if in typical cases:

- the previous snapshot event lies less than a month in the past
- since the previous snapshot event the Fish in question only subscribes to less than 1'000 events

As such, semantic snapshots can make a Fish viable even though it violates the recommendation in the previous section.

### The effect of state snapshots

State snapshots are written when the Fish’s event history is longer than 1'000 events and snapshots are enabled by providing a corresponding (de)serialization config.
When starting a Fish, the most recent state snapshot is used, thereby limiting the number of events that need to be applied.
This can help if the required events are large in number or dispersed over a long time range and many devices — which are both factors in requiring a longer time to find and deliver the events to the business logic.
It can also help if the business logic is computationally expensive, by reusing previously computed results.

One important aspect to keep in mind is that these snapshots are local to each device.
Therefore they don’t help when waking up a Fish for the first time on a given device — plowing through 10'000'000 events will take a long time even when the events can be found and delivered quickly.

### Large application state

State snapshots can be problematic when the business logic state is large.
If for example a Fish holds data structures with a volume of 100MB in memory, then storing a snapshot requires serializing this live data structure to JSON (which may separately take more than 100MB) and then sending it to ActyxOS for safe keeping.
Restoring a snapshot also requires both the serialized and the in-memory data structures to be live at the same time.

The above characteristics can cause problems especially in browser apps, where such memory usage spikes may lead to the app getting killed by the Javascript runtime.
Actual limits depend both on the runtime environment (which version of which browser) and on the available system memory, which in turn is handled differently between desktop PCs and tablet computers.

We recommend to keep per Fish memory usage below 10MB.

### Latency implications of large number of fishes and sources

With current ActyxOS versions the internal event dispatch latency is proportional to both the number of Fishes and the number of devices in the swarm.
The effect of this depends very much on the CPU that is running ActyxOS: for example 100 sources times 500 Fishes on an Intel Atom processor (rugged Android tablet from around 2015) lead to an internal latency of 3sec (e.g. between button click and subsequent fish state update).

We are working on improving this characteristic starting with release 1.1.5 and expect to remove this bottleneck in a future release.
Until then we recommend to keep the product of woken up Fishes and swarm sources below 1'000, at least on tablet computers.

### Pathological time travel performance when reconnecting a device that was offline for a long time

When reconnecting a device that was disconnected for a long time period, this device will need to ingest all new events from all other devices in the swarm to become up-to-date.
If a Fish is running during this process of catching up with the swarm, then that Fish will experience a lot more time travel than it would if it were woken up after ActyxOS is up-to-date.
ActyxOS optimises event delivery by doing it in chunks, nevertheless in pathological cases the amount of time travel is not linear in the number of such chunks but quadratic.

As an example: consider 10 devices to catch up with, each contributing 10 chunks of events for your Fish.
The optimal scenario would be to first catch up and then insert all 100 chunks into the event history, then perform one time travel.
The worst-case scenario would be that every chunk causes a time travel, with each subsequent time travel being more costly than the previous (due to added events).
Thereby, the Fish would process some events potentially a hundred times, more likely ten times (since chunks are ordered per device they come from).

To avoid this issue, we recommend using `Pond.waitForSwarmSync()` to delay app startup until ActyxOS is up-to-date with the rest of the swarm.

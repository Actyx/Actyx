---
title: How Actyx works
id: how-actyx-works
hide_title: false
hide_table_of_contents: false
image: /images/defaults/default.svg
---

## What is Actyx?

*High-level explanation of what Actyx is*

- Piece of software that runs on edge, mobile devices or desktop PCs
- decentralized event database, streaming and processing engine that allows you to easily build local-first cooperative apps.
- open-source toolkit that helps developers build apps that cooperate locally, without a backend.
- Actyx nodes build swarms that communicate via LAN / WLAN network using peer-to-peer communication
- Information is disseminated in the form of events (event sourcing)
- toolkit consists of Actyx (node), CLI & Node Manager to manage node, SDKs with useful abstractions to interact with events and build apps

## Actyx architecture

*Explain core components of a node and how CLI, NM or apps interact with a node*

![arch](../../static/images/conceptual/how-actyx-works/how-it-works.svg)

Todo NKI: make graphic nicer

### Node

- core of the node: event store for event dissemination and event storage
    - storage: banyan [https://crates.io/crates/banyan/0.1.3/dependencies](https://crates.io/crates/banyan/0.1.3/dependencies)
    - dissemination: libp2p [https://crates.io/crates/libp2p](https://crates.io/crates/libp2p)
- HTTP APIs **on [localhost](http://localhost)** to interact with core (publish / query events)

### CLI / Node Manager

- CLI: ergonomic command line interface for managing and configuring nodes
- Node Manager: offers same functionality as CLI + offers diagnostics tooling to monitor swarm connectivity

### Apps

- Actyx offers developer tooling to build local-first applications
    - SDKs: wrapper for more ergonomic use of HTTP APIs (Typescript and C#, Rust)
    - AQL: Retrieve, filter, transform, and aggregate with SQL-like structured queries
    - Pond:  programming model that allows you to easily build event-driven state machines that are automatically synchronised in your device swarm.
- Apps always work since they are only ever communicating locally with [localhost](http://localhost)

## Programming Model

- Build always-available apps that synchronise automatically
- Pond uses event sourcing: architectural pattern in which state is not stored directly, but rather computed as-needed from events stored in an event log.
- Pond guarantees eventual consistency: [https://developer.actyx.com/docs/how-to/actyx-pond/in-depth/eventual-consistency](https://developer.actyx.com/docs/how-to/actyx-pond/in-depth/eventual-consistency)

### Example

*Explain simple scenario and write one example fish (e.g. todo app)*

```jsx
interface Todo {
		id: string,
		description: string,
		done: boolean,
 }

interface TodoListState {
	todos: Todo[]
}

interface TodoChanged {
  type: 'todo-added' | 'todo-removed' | 'todo-changed',
	id: string,
	description?: string,
	done?: boolean
}

const TodoListFish : Fish<TodoListState, TodoChanged> = {
    fishId: FishId.of('todo-list', 'my-todo-fish', 0),
    initialState: [],
    where: Tag('todo-list'),
    onEvent: (state, event) => {
        switch (event.type) {
            case 'todo-added':
                state.push({
                  type: event.type,
                  id: event.id, 
                  description: event.description,
                  done: false
                })
                break
            case 'todo-removed':
                const pos = state.indexOf(event.id)
                if (pos !== -1) { state.splice(pos, 1) }
                break
            case 'todo-changed':
                state[event.id].done = !event.done
            default:
        }
        return state
    }
}
```

### Deployment

- One paragraph about general edge deployments (Kubernetes, Docker, APK, UDM)
- Links to relevant docs

### Resources

- link to tutorials
- link to releases
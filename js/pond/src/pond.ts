/*
 * Actyx Pond: A TypeScript framework for writing distributed apps
 * deployed on peer-to-peer networks, without any servers.
 * 
 * Copyright (C) 2020 Actyx AG
 */
/* eslint-disable @typescript-eslint/no-explicit-any */

import * as R from 'ramda'
import { Observable, ReplaySubject, Scheduler, Subject } from 'rxjs'
import { CommandInterface } from './commandInterface'
import { EventStore } from './eventstore'
import { MultiplexedWebsocket } from './eventstore/multiplexedWebsocket'
import { TestEventStore } from './eventstore/testEventStore'
import { ConnectivityStatus, Event, Events, UnstoredEvents } from './eventstore/types'
import { mkMultiplexer } from './eventstore/utils'
import { getSourceId } from './eventstore/websocketEventStore'
import { CommandExecutor } from './executors/commandExecutor'
import { CommandPipeline, FishJar } from './fishJar'
import log from './loggers'
import { mkPondStateTracker, PondState, PondStateTracker } from './pond-state'
import {
  Aggregate,
  CancelSubscription,
  Emit,
  EntityId,
  Metadata,
  PendingEmission,
  PondV2,
  Reduce,
  SimpleStateEffect,
  StateEffect,
  TagQuery,
} from './pond-v2-types'
import { SnapshotStore } from './snapshotStore'
import { Config as WaitForSwarmConfig, SplashState } from './splashState'
import { Monitoring } from './store/monitoring'
import { SubscriptionSet, subscriptionsToEventPredicate } from './subscription'
import {
  Envelope,
  FishName,
  FishType,
  FishTypeImpl,
  Lamport,
  Milliseconds,
  ObserveMethod,
  Psn,
  Semantics,
  SendCommand,
  Source,
  SourceId,
  StateWithProvenance,
  Timestamp,
} from './types'

type AnyFishJar = FishJar<any, any, any>

export type EventChunkOld<E> = {
  source: Source
  timestamp: Timestamp
  events: ReadonlyArray<E>
}
/**
 * Makes a chunk from a number of envelopes
 *
 * This is exclusively needed in old tests and should be removed once the tests are
 * refactored.
 * @param envelopes A number of envelopes
 */
export const mkEventChunk = <E>(envelopes: ReadonlyArray<Envelope<E>>): EventChunkOld<E> => {
  if (envelopes.length === 0) {
    throw new Error()
  }
  const source = envelopes[0].source

  const timestamp = envelopes[0].timestamp
  const events = envelopes.map(x => x.payload)
  if (envelopes.length > 1) {
    if (!envelopes.every(x => R.equals(x.source, source))) {
      throw new Error('all events must have the same source')
    }
    if (!envelopes.every(x => R.equals(x.timestamp, timestamp))) {
      throw new Error('all events must have the same timestamp')
    }
  }
  return {
    timestamp,
    source,
    events,
  }
}

export type SendToStore = <E>(
  semantics: Semantics,
  fishName: FishName,
  tags: string[],
  events: ReadonlyArray<E>,
) => Observable<Events>

/**
 * @deprecated
 * As the PSN is given out by the store, we can't do this conversion anymore.
 * Should be only used for testing purposes.
 */
export function flattenChunk(chunk: UnstoredEvents, sourceId: SourceId): Event[] {
  return chunk.map(event => {
    const result = {
      name: event.name,
      semantics: event.semantics,
      tags: event.tags,
      sourceId,
      psn: Psn.of(-1),
      lamport: Lamport.of(0), // deprecated - test use only
      timestamp: event.timestamp,
      payload: event.payload,
    }
    return result
  })
}

export type PondInfo = {
  sourceId: SourceId
}
export type Pond = {
  /**
   * Obtain an observable stream of states from the given fish, waking it up if it is
   * not already actively running within this pond. It is guaranteed that after a
   * change in state there will eventually be a current state object emitted by the
   * returned observable, but not every intermediate state is guaranteed to be emitted.
   */
  observe<C, E, P>(fish: FishType<C, E, P>, name: string): Observable<P>

  /**
   * Send a command to the given fish, ensuring that it is woken up within this pond.
   * Processing a command usually results in the generation of events (which in turn
   * trigger observable state changes) or other effects. The events are emitted and
   * applied first (with running of effects as described for runEvent(), but without
   * dispatching intermediate state updates), then effects
   * are executed, followed finally by dispatching the new state if a change in state
   * did in fact occur.
   *
   * Observable completes when command execution finishes.
   *
   * NOTE that this method returns a lazy observable, i.e. if not consumed then the
   * command is also not sent.
   *
   * We are using two argument lists to help the type inference. The first argument list
   * fully determines C, and the second argument list just has to check for matching.
   */
  feed<C, E, P>(fish: FishType<C, E, P>, name: string): (command: C) => Observable<void>

  /**
   * @deprecated
   * Events as they are generated by the processing of commands (feed), flattened
   */
  _events(): Observable<Envelope<any>>

  /**
   * Commands as they are generated by the processing of commands (feed)
   */
  commands(): Observable<SendCommand<any>>

  /**
   * Dump all internal state of all fish, for debugging purposes.
   */
  dump(): Observable<string>

  /**
   * Dispose subscription to IpfsStore
   * Store subscription needs to be unsubscribed for HMR
   */
  dispose(): Promise<void>

  /**
   * Information about the current pond
   */
  info(): PondInfo

  /**
   * Obtain an observable state of the pond.
   */
  getPondState(): Observable<PondState>

  /**
   * Obtain an observable describing connectivity status of this node.
   */
  getNodeConnectivity(...specialSources: ReadonlyArray<SourceId>): Observable<ConnectivityStatus>

  /**
   * Obtain an observable that completes when we are mostly in sync with the swarm.
   * It is recommended to wait for this on application startup, before interacting with any fish,
   * i.e. `await pond.waitForSwarmSync().toPromise()`. The intermediate states emitted
   * by the Observable can be used to display render a progress bar, for example.
   */
  waitForSwarmSync(config?: WaitForSwarmConfig): Observable<SplashState>
}

const logPondError = { error: (x: any) => log.pond.error(JSON.stringify(x)) }

export type TimeInjector = (source: Source, events: ReadonlyArray<any>) => Timestamp

export const defaultTimeInjector: TimeInjector = (_source: Source, _events: ReadonlyArray<any>) =>
  Timestamp.now()

export type Tap<T> = (xs: Observable<T>) => Observable<T>
const identity = <T>(x: Observable<T>) => x
export const Tap = {
  none: identity,
}
export type CommandTap = Tap<SendCommand<any>>
export type EventTap = Tap<UnstoredEvents>
export type PondOptions = {
  timeInjector?: TimeInjector
  commandTap?: CommandTap
  eventTap?: EventTap

  hbHistDelay?: number
  currentPsnHistoryDelay?: number
  updateConnectivityEvery?: Milliseconds
}

const defaultPondOptions = {
  timeInjector: defaultTimeInjector,
}

export const makeEventChunk = <E>(
  timeInjector: TimeInjector,
  source: Source,
  events: ReadonlyArray<E>,
): UnstoredEvents => {
  const timestamp = timeInjector(source, events)
  const { semantics, name } = source
  return events.map(payload => ({
    semantics,
    name,
    tags: [],
    timestamp,
    payload,
  }))
}

const omitObservable = <S>(
  callback: (newState: S) => void,
  states: Observable<StateWithProvenance<S>>,
): CancelSubscription => {
  const sub = states.map(x => x.state).subscribe(callback)
  return sub.unsubscribe.bind(sub)
}

const pendingEmission = (o: Observable<void>): PendingEmission => ({
  subscribe: o.subscribe.bind(o),
  toPromise: () => o.toPromise(),
})

type ActiveAggregate<S> = {
  readonly states: Observable<StateWithProvenance<S>>
  commandPipeline?: CommandPipeline<S, ReadonlyArray<Emit<any>>>
}

type BothPonds = Pond & PondV2
export class PondImpl implements BothPonds {
  commandsSubject: Subject<SendCommand<any>> = new Subject()
  eventsSubject: Subject<UnstoredEvents> = new Subject()
  timeInjector: TimeInjector
  eventTap: EventTap

  readonly hydrateV2: <S, E>(
    subscriptionSet: SubscriptionSet,
    initialState: S,
    onEvent: (state: S, event: E, metadata: Metadata) => S,
    entityId: EntityId,
    enableLocalSnapshots: boolean,
    isReset?: (event: E) => boolean,
  ) => Observable<StateWithProvenance<S>>

  // fish containers
  jars: {
    [semantics: string]: { [name: string]: ReplaySubject<AnyFishJar> }
  } = {}

  taggedAggregates: {
    [entityId: string]: ActiveAggregate<any>
  } = {}

  // executor for async commands
  commandExecutor: CommandExecutor

  constructor(
    readonly eventStore: EventStore,
    readonly snapshotStore: SnapshotStore,
    readonly pondStateTracker: PondStateTracker,
    readonly monitoring: Monitoring,
    readonly opts: PondOptions,
  ) {
    this.eventTap = opts.eventTap || Tap.none
    this.timeInjector = opts.timeInjector ? opts.timeInjector : defaultPondOptions.timeInjector

    const config = {
      getState: <P>(f: FishType<any, any, P>, name: FishName): Promise<P> => {
        return this.observe(f, name)
          .take(1)
          .toPromise()
      },
      sendCommand: <T>(sc: SendCommand<T>) => {
        this.commandsSubject.next(sc)
      },
    }
    this.commandExecutor = CommandExecutor(config)

    this.hydrateV2 = FishJar.hydrateV2(this.eventStore, this.snapshotStore, this.pondStateTracker)
  }

  getPondState = (): Observable<PondState> => this.pondStateTracker.observe()

  getNodeConnectivity = (
    ...specialSources: ReadonlyArray<SourceId>
  ): Observable<ConnectivityStatus> =>
    this.eventStore.connectivityStatus(
      specialSources,
      this.opts.hbHistDelay || 1e12,
      this.opts.updateConnectivityEvery || Milliseconds.of(10_000),
      this.opts.currentPsnHistoryDelay || 6,
    )

  waitForSwarmSync = (config?: WaitForSwarmConfig): Observable<SplashState> =>
    SplashState.of(this.eventStore, config || {})

  commands = () => {
    return this.commandsSubject.asObservable()
  }

  // deprecated, testing use only
  _events = () => {
    return this.eventsSubject.mergeMap(c =>
      flattenChunk(c, this.eventStore.sourceId).map(ev => Event.toEnvelopeFromStore<any>(ev)),
    )
  }

  observe = <C, E, P>(fish: FishType<C, E, P>, name: string): Observable<P> => {
    return this.getOrHydrateJar(FishTypeImpl.downcast(fish), FishName.of(name)).concatMap(
      jar => jar.publicSubject,
    )
  }

  allFishJars = (): Observable<AnyFishJar> => {
    return Observable.of(this.jars)
      .concatMap(f => Observable.from(Object.keys(f)).map(k => f[k]))
      .concatMap(f => Observable.from(Object.keys(f)).map(k => f[k]))
      .concatMap(x => x)
  }

  dump = (): Observable<string> => {
    return this.allFishJars()
      .map(s => s.dump())
      .toArray()
      .map(arr => arr.join('\n'))
  }

  getOrHydrateJar = (
    fish: FishTypeImpl<any, any, any, any>,
    name: FishName,
  ): Observable<AnyFishJar> => {
    const semantics = fish.semantics
    const jarPath = [semantics, name]
    const existingSubject = R.pathOr<undefined, ReplaySubject<AnyFishJar>>(
      undefined,
      jarPath,
      this.jars,
    )

    if (existingSubject !== undefined) {
      return existingSubject.observeOn(Scheduler.queue).take(1)
    }

    const subject = new ReplaySubject<AnyFishJar>(1)
    this.jars = R.assocPath(jarPath, subject, this.jars)
    const storeEvents: SendToStore = (semantics, fishName, _tags, events) => {
      const source = {
        sourceId: this.eventStore.sourceId,
        semantics,
        name: fishName,
      }

      const chunk = makeEventChunk(this.timeInjector, source, events)
      return Observable.of(chunk).concatMap(x => {
        this.eventsSubject.next(x)
        return this.eventStore.persistEvents(chunk)
      })
    }

    FishJar.hydrate(
      fish,
      name,
      this.eventStore,
      this.snapshotStore,
      storeEvents,
      this.observe as ObserveMethod,
      this.commandExecutor,
      this.pondStateTracker,
    ).subscribe(subject)
    return subject
  }

  feed0 = <C, E, P>(fish: FishType<C, E, P>, name: FishName, command: C): Observable<void> => {
    return this.getOrHydrateJar(FishTypeImpl.downcast(fish), name).mergeMap(
      jar =>
        new Observable<void>(x =>
          jar.enqueueCommand(
            command,
            () => {
              x.next()
              x.complete()
            },
            err => x.error(err),
          ),
        ),
    )
  }

  feed = <C, E, P>(fish: FishType<C, E, P>, name: FishName) => {
    return (command: C) => this.feed0(fish, name, command)
  }

  info = () => {
    return {
      sourceId: this.eventStore.sourceId,
    }
  }

  dispose = () => {
    this.monitoring.dispose()
    return this.allFishJars()
      .do(jar => jar.dispose())
      .defaultIfEmpty(undefined)
      .last()
      .do(() => (this.jars = {}))
      .mapTo(undefined)
      .toPromise()
  }

  /* POND V2 FUNCTIONS */
  private emitTagged0 = <E>(emit: ReadonlyArray<Emit<E>>): Observable<Events> => {
    const semantics = Semantics.none
    const name = FishName.none

    const source = {
      sourceId: this.eventStore.sourceId,
      semantics,
      name,
    }

    const events = emit.map(({ tags, payload }) => {
      const timestamp = this.timeInjector(source, [payload])

      const event = {
        semantics: Semantics.none,
        name,
        tags,
        timestamp,
        payload,
      }

      return event
    })

    return this.eventStore.persistEvents(events)
  }

  emitEvent = (tags: ReadonlyArray<string>, payload: unknown): PendingEmission => {
    return this.emitEvents({ tags, payload })
  }

  emitEvents = (...emissions: ReadonlyArray<Emit<any>>): PendingEmission => {
    // `shareReplay` so that every piece of user code calling `subscribe`
    // on the return value will actually be executed
    const o = this.emitTagged0(emissions)
      .mapTo(void 0)
      .shareReplay(1)

    // `o` is already (probably) hot, but we subscribe just in case.
    o.subscribe()

    return pendingEmission(o)
  }

  private getCachedOrInitialize = <S, E>(
    subscriptionSet: SubscriptionSet,
    initialState: S,
    onEvent: Reduce<S, E>,
    entityId: EntityId,
    isReset?: (event: E) => boolean,
  ): ActiveAggregate<S> => {
    const key = EntityId.canonical(entityId)
    const existing = this.taggedAggregates[key]
    if (existing !== undefined) {
      return {
        states: existing.states.observeOn(Scheduler.queue),
        ...existing,
      }
    }

    const stateSubject = this.hydrateV2(
      subscriptionSet,
      initialState,
      onEvent,
      entityId,
      true,
      isReset,
    ).shareReplay(1)

    const a = {
      states: stateSubject,
    }
    this.taggedAggregates[key] = a
    return a
  }

  aggregateUncached = <S, E>(
    requiredTags: ReadonlyArray<string>,
    initialState: S,
    onEvent: (state: S, event: E) => S,
    callback: (newState: S) => void,
  ): CancelSubscription => {
    const subscriptionSet: SubscriptionSet = {
      type: 'tags',
      subscriptions: [{ tags: requiredTags, local: false }],
    }

    return omitObservable(
      callback,
      this.hydrateV2(
        subscriptionSet,
        initialState,
        onEvent,
        { name: String(Math.random()) },
        false,
      ),
    )
  }

  aggregatePlain = <S, E>(
    requiredTags: ReadonlyArray<string>,
    initialState: S,
    onEvent: (state: S, event: E) => S,
    cacheKey: EntityId,
    callback: (newState: S) => void,
  ): CancelSubscription => {
    const subscriptionSet: SubscriptionSet = {
      type: 'tags',
      subscriptions: [{ tags: requiredTags, local: false }],
    }

    return omitObservable(
      callback,
      this.getCachedOrInitialize(subscriptionSet, initialState, onEvent, cacheKey).states,
    )
  }

  private observeTagBased0 = <S, E>(acc: Aggregate<S, E>): ActiveAggregate<S> => {
    const subscriptionSet: SubscriptionSet = {
      type: 'tags',
      subscriptions: TagQuery.toWireFormat(acc.subscriptions),
    }

    return this.getCachedOrInitialize(
      subscriptionSet,
      acc.initialState,
      acc.onEvent,
      acc.entityId,
      acc.isReset,
    )
  }

  aggregate = <S, E>(acc: Aggregate<S, E>, callback: (newState: S) => void): CancelSubscription => {
    if (acc.deserializeState) {
      throw new Error('custom deser not yet supported')
    }

    return omitObservable(callback, this.observeTagBased0<S, E>(acc).states)
  }

  // Get a (cached) Handle to run StateEffects against. Every Effect will see the previous one applied to the State.
  getOrCreateCommandHandle = <S>(
    agg: Aggregate<S, any>,
  ): ((effect: StateEffect<S, any>) => PendingEmission) => {
    const cached = this.observeTagBased0(agg)

    const handler = (emit: ReadonlyArray<Emit<any>>) => {
      return this.emitTagged0(emit)
    }

    const subscriptionSet: SubscriptionSet = {
      type: 'tags',
      subscriptions: TagQuery.toWireFormat(agg.subscriptions),
    }

    const commandPipeline =
      cached.commandPipeline ||
      FishJar.commandPipeline<S, ReadonlyArray<Emit<any>>>(
        this.pondStateTracker,
        this.eventStore.sourceId,
        agg.entityId.entityType || Semantics.none,
        agg.entityId.name,
        handler,
        cached.states,
        subscriptionsToEventPredicate(subscriptionSet),
      )
    cached.commandPipeline = commandPipeline

    return effect => {
      const o = new Observable<void>(x =>
        commandPipeline.subject.next({
          type: 'command',
          command: effect,
          onComplete: () => {
            x.next()
            x.complete()
          },
          onError: (err: any) => x.error(err),
        }),
      )

      return pendingEmission(o)
    }
  }

  getOrCreateCommandHandleFixedTags = <S, E>(
    agg: Aggregate<S, any>,
    tags: string[],
  ): ((effect: SimpleStateEffect<S, E>) => PendingEmission) => {
    const handle = this.getOrCreateCommandHandle(agg)

    return effect => {
      const fixedEffect = (s: S) => effect(s).map(payload => ({ tags, payload }))
      return handle(fixedEffect)
    }
  }

  runStateEffect = <S>(agg: Aggregate<S, any>, effect: StateEffect<S, any>): PendingEmission => {
    const handle = this.getOrCreateCommandHandle(agg)
    return handle(effect)
  }
}

/**
 * All services needed by the pond
 */
type Services = Readonly<{
  eventStore: EventStore
  snapshotStore: SnapshotStore
  commandInterface: CommandInterface
}>

const mockSetup = (): Services => {
  const eventStore = EventStore.mock()
  const snapshotStore = SnapshotStore.inMem()
  const commandInterface = CommandInterface.mock()
  return { eventStore, snapshotStore, commandInterface }
}

const createServices = async (multiplexer: MultiplexedWebsocket): Promise<Services> => {
  const sourceId = await getSourceId(multiplexer)
  const eventStore = EventStore.ws(multiplexer, sourceId)
  const snapshotStore = SnapshotStore.ws(multiplexer)
  const commandInterface = CommandInterface.ws(multiplexer, sourceId)
  return { eventStore, snapshotStore, commandInterface }
}

const mkPond = async (
  multiplexer: MultiplexedWebsocket,
  opts: PondOptions = {},
): Promise<BothPonds> => {
  const services = await createServices(multiplexer || mkMultiplexer())
  return pondFromServices(services, opts)
}

const mkMockPond = async (opts?: PondOptions): Promise<Pond> => {
  const opts1: PondOptions = opts || {}
  const services = mockSetup()
  return pondFromServices(services, opts1)
}

type TestPond = BothPonds & {
  directlyPushEvents: (events: Events) => void
  eventStore: TestEventStore
}
const mkTestPond = async (opts?: PondOptions): Promise<TestPond> => {
  const opts1: PondOptions = opts || {}
  const eventStore = EventStore.test(SourceId.of('TEST'))
  const snapshotStore = SnapshotStore.inMem()
  const commandInterface = CommandInterface.mock()
  return {
    ...pondFromServices({ eventStore, snapshotStore, commandInterface }, opts1),
    directlyPushEvents: eventStore.directlyPushEvents,
    eventStore,
  }
}
const pondFromServices = (services: Services, opts: PondOptions): BothPonds => {
  const { eventStore, snapshotStore, commandInterface } = services

  const monitoring = Monitoring.of(commandInterface, 10000)

  log.pond.debug('start pond with SourceID %s from store', eventStore.sourceId)

  const pondStateTracker = mkPondStateTracker(log.pond)
  const pond: PondImpl = new PondImpl(eventStore, snapshotStore, pondStateTracker, monitoring, opts)
  // execute commands by calling feed
  pond.commandsSubject
    .pipe(opts.commandTap || Tap.none)
    .mergeMap(s => pond.feed0(s.target.semantics, FishName.of(s.target.name), s.command))
    .subscribe(logPondError)

  return pond
}

export const Pond = {
  default: async (): Promise<BothPonds> => Pond.of(mkMultiplexer()),
  of: mkPond,
  mock: mkMockPond,
  test: mkTestPond,
}

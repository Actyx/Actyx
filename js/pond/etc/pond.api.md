## API Report File for "@actyx/pond"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { ActyxOpts } from '@actyx/sdk';
import { CancelSubscription } from '@actyx/sdk';
import * as immutable from 'immutable';
import { Metadata } from '@actyx/sdk';
import { Milliseconds } from '@actyx/sdk';
import { NodeId } from '@actyx/sdk';
import { PendingEmission } from '@actyx/sdk';
import { Tags } from '@actyx/sdk';
import { TestEvent } from '@actyx/sdk';
import { Where } from '@actyx/sdk';

// @public
export type AddEmission<EWrite> = <E extends EWrite>(tags: Tags<E>, event: E) => void;

// @beta
export type Caching = NoCaching | InProcessCaching;

// @beta
export const Caching: {
    none: {
        type: "none";
    };
    isEnabled: (c: Caching | undefined) => c is Readonly<{
        type: 'in-process';
        key: string;
    }>;
    inProcess: (key: string) => Caching;
};

// @public
export type Counters = Readonly<CountersMut>;

// @public
export type CountersMut = {
    own: number;
    swarm: number;
    both: number;
};

// @public
export type Fish<S, E> = Readonly<{
    where: Where<E>;
    initialState: S;
    onEvent: Reduce<S, E>;
    fishId: FishId;
    isReset?: IsReset<E>;
    deserializeState?: (jsonState: unknown) => S;
}>;

// @public
export const Fish: {
    latestEvent: <E>(where: Where<E>) => Readonly<{
        where: Where<E>;
        initialState: E | undefined;
        onEvent: Reduce<E | undefined, E>;
        fishId: FishId;
        isReset?: IsReset<E> | undefined;
        deserializeState?: ((jsonState: unknown) => E | undefined) | undefined;
    }>;
    eventsDescending: <E_1>(where: Where<E_1>, capacity?: number) => Readonly<{
        where: Where<E_1>;
        initialState: E_1[];
        onEvent: Reduce<E_1[], E_1>;
        fishId: FishId;
        isReset?: IsReset<E_1> | undefined;
        deserializeState?: ((jsonState: unknown) => E_1[]) | undefined;
    }>;
    eventsAscending: <E_2>(where: Where<E_2>, capacity?: number) => Readonly<{
        where: Where<E_2>;
        initialState: E_2[];
        onEvent: Reduce<E_2[], E_2>;
        fishId: FishId;
        isReset?: IsReset<E_2> | undefined;
        deserializeState?: ((jsonState: unknown) => E_2[]) | undefined;
    }>;
};

// @public
export type FishErrorContext = {
    occuredIn: 'onEvent';
    state: unknown;
    event: unknown;
    metadata: Metadata;
} | {
    occuredIn: 'isReset';
    event: unknown;
    metadata: Metadata;
} | {
    occuredIn: 'deserializeState';
    jsonState: unknown;
};

// @public
export type FishErrorReporter = (err: unknown, fishId: FishId, detail: FishErrorContext) => void;

// @public
export type FishId = {
    entityType: string;
    name: string;
    version: number;
};

// @public
export const FishId: {
    of: (entityType: string, name: string, version: number) => {
        entityType: string;
        name: string;
        version: number;
    };
    canonical: (v: FishId) => string;
};

// @public
export type FishProcessInfo = {
    numBeingProcessed: number;
    fish: {
        [semantics: string]: true | undefined;
    };
};

// @public
export type FullWaitForSwarmConfig = Readonly<{
    enabled: boolean;
    waitForSwarmMs: number;
    minSources: number;
    waitForSyncMs?: number;
    allowSkip: boolean;
}>;

// @public
export type GetNodeConnectivityParams = Readonly<{
    callback: (newState: unknown) => void;
    specialSources?: ReadonlyArray<NodeId>;
}>;

// @beta
export type InProcessCaching = Readonly<{
    type: 'in-process';
    key: string;
}>;

// @public
export type IsReset<E> = (event: E, metadata: Metadata) => boolean;

// @beta
export type NoCaching = {
    readonly type: 'none';
};

// @public
export type NodeInfoEntry = Readonly<{
    own?: number;
    swarm?: number;
}>;

// @beta
export type ObserveAllOpts = Partial<{
    caching: Caching;
    expireAfterSeed: Milliseconds;
    expireAfterFirst: Milliseconds;
}>;

// @public
export type PendingCommand = {
    subscribe: (whenEmitted: () => void) => void;
    toPromise: () => Promise<void>;
};

// @public
export type Pond = {
    emit<E>(tags: Tags<E>, event: E): PendingEmission;
    observe<S, E>(fish: Fish<S, E>, callback: (newState: S) => void, stoppedByError?: (err: unknown) => void): CancelSubscription;
    observeAll<ESeed, S>(seedEventsSelector: Where<ESeed>, makeFish: (seedEvent: ESeed) => Fish<S, any> | undefined, opts: ObserveAllOpts, callback: (states: S[]) => void): CancelSubscription;
    observeOne<ESeed, S>(seedEventSelector: Where<ESeed>, makeFish: (seedEvent: ESeed) => Fish<S, any>, callback: (newState: S) => void, stoppedByError?: (err: unknown) => void): CancelSubscription;
    run<S, EWrite>(fish: Fish<S, any>, fn: StateEffect<S, EWrite>): PendingCommand;
    keepRunning<S, EWrite>(fish: Fish<S, any>, fn: StateEffect<S, EWrite>, autoCancel?: (state: S) => boolean): CancelSubscription;
    dispose(): void;
    info(): PondInfo;
    getPondState(callback: (newState: PondState) => void): CancelSubscription;
    getNodeConnectivity(params: GetNodeConnectivityParams): CancelSubscription;
    waitForSwarmSync(params: WaitForSwarmSyncParams): void;
};

// @public
export const Pond: {
    default: () => Promise<Pond>;
    of: (connectionOpts: ActyxOpts, opts: PondOptions) => Promise<Pond>;
    test: (opts?: PondOptions | undefined) => TestPond;
};

// @public
export type PondInfo = {
    nodeId: NodeId;
};

// @public
export type PondOptions = {
    hbHistDelay?: number;
    currentPsnHistoryDelay?: number;
    updateConnectivityEvery?: Milliseconds;
    stateEffectDebounce?: number;
    fishErrorReporter?: FishErrorReporter;
};

// @public
export type PondState = {
    hydration: FishProcessInfo;
    commands: FishProcessInfo;
    eventsFromOtherSources: FishProcessInfo;
};

// @public
export const PondState: {
    isHydrating: (state: PondState) => boolean;
    isProcessingCommands: (state: PondState) => boolean;
    isProcessingEventsFromOtherSources: (state: PondState) => boolean;
    isBusy: (state: PondState) => boolean;
};

// @public
export type Progress = Readonly<{
    min: number;
    current: number;
    max: number;
}>;

// @public
export type Reduce<S, E> = (state: S, event: E, metadata: Metadata) => S;

// @public
export type SplashState = SplashStateDiscovery | SplashStateSync;

// @public
export type SplashStateDiscovery = Readonly<{
    mode: 'discovery';
    current: SwarmSummary;
    skip?: () => void;
}>;

// @public
export type SplashStateSync = Readonly<{
    mode: 'sync';
    reference: SwarmSummary;
    progress: SyncProgress;
    current: SwarmSummary;
    skip?: () => void;
}>;

// @public
export type StateEffect<S, EWrite> = (state: S, enqueue: AddEmission<EWrite>) => void | Promise<void>;

// @public
export type StoreConfig = Readonly<{
    monitoringMeta?: object;
    metaMs: number;
    runStatsPeriodMs: number;
}>;

// @public
export type SwarmInfo = Readonly<{
    nodes: immutable.Map<string, NodeInfoEntry>;
}>;

// @public
export type SwarmSummary = Readonly<{
    info: SwarmInfo;
    sources: Counters;
    events: Counters;
}>;

// @public
export const SwarmSummary: {
    empty: Readonly<{
        info: SwarmInfo;
        sources: Counters;
        events: Counters;
    }>;
    fromSwarmInfo: (info: SwarmInfo) => SwarmSummary;
};

// @public
export type SyncProgress = Readonly<{
    sources: Progress;
    events: Progress;
}>;

// @public
export type TestPond = Pond & {
    directlyPushEvents: (events: TestEvent[]) => void;
};

// @public
export const unreachable: (x?: never) => never;

// @public
export function unreachableOrElse<T>(_: never, t: T): T;

// @public
export type WaitForSwarmConfig = Partial<FullWaitForSwarmConfig>;

// @public
export const WaitForSwarmConfig: {
    defaults: Readonly<{
        enabled: boolean;
        waitForSwarmMs: number;
        minSources: number;
        waitForSyncMs?: number | undefined;
        allowSkip: boolean;
    }>;
};

// @public
export type WaitForSwarmSyncParams = WaitForSwarmConfig & Readonly<{
    onSyncComplete: () => void;
    onProgress?: (newState: SplashState) => void;
}>;


export * from "@actyx/sdk";

// (No @packageDocumentation comment for this package)

```

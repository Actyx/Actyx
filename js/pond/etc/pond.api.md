## API Report File for "@actyx/pond"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { Actyx } from '@actyx/sdk';
import { ActyxOpts } from '@actyx/sdk';
import { AppManifest } from '@actyx/sdk';
import { CancelSubscription } from '@actyx/sdk';
import * as immutable from 'immutable';
import { Metadata } from '@actyx/sdk';
import { Milliseconds } from '@actyx/sdk';
import { NodeId } from '@actyx/sdk';
import { NodeInfo } from '@actyx/sdk';
import { PendingEmission } from '@actyx/sdk';
import { TaggedEvent } from '@actyx/sdk';
import { TaggedTypedEvent } from '@actyx/sdk';
import { Tags } from '@actyx/sdk';
import { TestEvent } from '@actyx/sdk';
import { TimeInjector } from '@actyx/sdk';
import { Where } from '@actyx/sdk';

// @public
export type AddEmission<EWrite> = <E extends EWrite>(...args: [Tags<E>, E] | [TaggedTypedEvent<E>]) => void;

// @beta
export type Caching = NoCaching | InProcessCaching;

// @beta
export const Caching: {
    none: {
        type: "none";
    };
    isEnabled: (c: Caching | undefined) => c is InProcessCaching;
    inProcess: (key: string) => Caching;
};

// @public
export type Counters = Readonly<CountersMut>;

// @public
export type CountersMut = {
    own: number;
    swarm: number;
    both: number;
};

// @public
export type Fish<S, E> = {
    where: Where<E>;
    initialState: S;
    onEvent: Reduce<S, E>;
    fishId: FishId;
    isReset?: IsReset<E>;
    deserializeState?: (jsonState: unknown) => S;
};

// @public
export const Fish: {
    latestEvent: <E>(where: Where<E>) => Fish<E | undefined, E>;
    eventsDescending: <E_1>(where: Where<E_1>, capacity?: number) => Fish<E_1[], E_1>;
    eventsAscending: <E_2>(where: Where<E_2>, capacity?: number) => Fish<E_2[], E_2>;
};

// @public
export type FishErrorContext = {
    occuredIn: 'onEvent';
    state: unknown;
    event: unknown;
    metadata: Metadata;
} | {
    occuredIn: 'isReset';
    event: unknown;
    metadata: Metadata;
} | {
    occuredIn: 'deserializeState';
    jsonState: unknown;
};

// @public
export type FishErrorReporter = (err: unknown, fishId: FishId, detail: FishErrorContext) => void;

// @public
export type FishId = {
    entityType: string;
    name: string;
    version: number;
};

// @public
export const FishId: {
    of: (entityType: string, name: string, version: number) => {
        entityType: string;
        name: string;
        version: number;
    };
    canonical: (v: FishId) => string;
};

// @public
export type FishProcessInfo = {
    numBeingProcessed: number;
    fish: {
        [semantics: string]: true | undefined;
    };
};

// @public
export type FullWaitForSwarmConfig = {
    enabled: boolean;
    waitForSwarmMs: number;
    minSources: number;
    waitForSyncMs?: number;
    allowSkip: boolean;
};

// @public
export type GetNodeConnectivityParams = {
    callback: (newState: unknown) => void;
    specialSources?: NodeId[];
};

// @beta
export type InProcessCaching = {
    type: 'in-process';
    key: string;
};

// @public
export type IsReset<E> = (event: E, metadata: Metadata) => boolean;

// @beta
export type NoCaching = {
    readonly type: 'none';
};

// @public
export type NodeInfoEntry = {
    own?: number;
    swarm?: number;
};

// @beta
export type ObserveAllOpts = Partial<{
    caching: Caching;
    expireAfterSeed: Milliseconds;
    expireAfterFirst: Milliseconds;
}>;

// @public
export type PendingCommand = {
    subscribe: (whenEmitted: () => void) => void;
    toPromise: () => Promise<void>;
};

// @public
export type Pond = {
    emit<E>(tags: Tags<E>, event: E): PendingEmission;
    publish(event: TaggedEvent): Promise<Metadata>;
    publish(events: TaggedEvent[]): Promise<Metadata[]>;
    observe<S, E>(fish: Fish<S, E>, callback: (newState: S) => void, stoppedByError?: (err: unknown) => void): CancelSubscription;
    currentState<S, E>(fish: Fish<S, E>): Promise<S>;
    observeAll<ESeed, S>(seedEventsSelector: Where<ESeed>, makeFish: (seedEvent: ESeed) => Fish<S, any> | undefined, opts: ObserveAllOpts, callback: (states: S[]) => void): CancelSubscription;
    observeOne<ESeed, S>(seedEventSelector: Where<ESeed>, makeFish: (seedEvent: ESeed) => Fish<S, any>, callback: (newState: S) => void, stoppedByError?: (err: unknown) => void): CancelSubscription;
    run<S, EWrite>(fish: Fish<S, any>, fn: StateEffect<S, EWrite>): PendingCommand;
    keepRunning<S, EWrite>(fish: Fish<S, any>, fn: StateEffect<S, EWrite>, autoCancel?: (state: S) => boolean): CancelSubscription;
    dispose(): void;
    info(): PondInfo;
    nodeInfo(maxAgeMillis: number): Promise<NodeInfo>;
    getPondState(callback: (newState: PondState) => void): CancelSubscription;
    waitForSwarmSync(params: WaitForSwarmSyncParams): void;
    events(): Actyx;
};

// @public
export const Pond: {
    default: (manifest: AppManifest) => Promise<Pond>;
    of: (manifest: AppManifest, connectionOpts: ActyxOpts, opts: PondOptions) => Promise<Pond>;
    from: (actyx: Actyx, opts: PondOptions) => Pond;
    test: (opts?: TestPondOptions | undefined) => TestPond;
};

// @public
export type PondInfo = {
    nodeId: NodeId;
};

// @public
export type PondOptions = {
    fishErrorReporter?: FishErrorReporter;
};

// @public
export type PondState = {
    hydration: FishProcessInfo;
    commands: FishProcessInfo;
    eventsFromOtherSources: FishProcessInfo;
};

// @public
export const PondState: {
    isHydrating: (state: PondState) => boolean;
    isProcessingCommands: (state: PondState) => boolean;
    isProcessingEventsFromOtherSources: (state: PondState) => boolean;
    isBusy: (state: PondState) => boolean;
};

// @public
export type Progress = {
    min: number;
    current: number;
    max: number;
};

// @public
export type Reduce<S, E> = (state: S, event: E, metadata: Metadata) => S;

// @public
export type SplashState = SplashStateDiscovery | SplashStateSync;

// @public
export type SplashStateDiscovery = {
    mode: 'discovery';
    current: SwarmSummary;
    skip?: () => void;
};

// @public
export type SplashStateSync = {
    mode: 'sync';
    reference: SwarmSummary;
    progress: SyncProgress;
    current: SwarmSummary;
    skip?: () => void;
};

// @public
export type StateEffect<S, EWrite> = (state: S, enqueue: AddEmission<EWrite>, pond: Pond) => void | Promise<void>;

// @public
export type SwarmInfo = {
    nodes: immutable.Map<string, NodeInfoEntry>;
};

// @public
export type SwarmSummary = {
    info: SwarmInfo;
    sources: Counters;
    events: Counters;
};

// @public
export const SwarmSummary: {
    empty: SwarmSummary;
    fromSwarmInfo: (info: SwarmInfo) => SwarmSummary;
};

// @public
export type SyncProgress = {
    sources: Progress;
    events: Progress;
};

// @public
export type TestPond = Pond & {
    directlyPushEvents: (events: TestEvent[]) => void;
};

// @public
export type TestPondOptions = PondOptions & {
    timeInjector?: TimeInjector;
};

// @public
export const unreachable: (x?: never) => never;

// @public
export function unreachableOrElse<T>(_: never, t: T): T;

// @public
export type WaitForSwarmConfig = Partial<FullWaitForSwarmConfig>;

// @public
export const WaitForSwarmConfig: {
    defaults: FullWaitForSwarmConfig;
};

// @public
export type WaitForSwarmSyncParams = WaitForSwarmConfig & {
    onSyncComplete: () => void;
    onProgress?: (newState: SplashState) => void;
};


export * from "@actyx/sdk";

// (No @packageDocumentation comment for this package)

```

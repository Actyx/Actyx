## API Report File for "@actyx/sdk"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { Ord } from 'fp-ts/lib/Ord';
import * as t from 'io-ts';

// @public
export type Actyx = EventFns & {
    dispose: () => void;
};

// @public
export const Actyx: {
    of: (manifest: AppManifest, opts?: ActyxOpts) => Promise<Actyx>;
    test: (opts?: ActyxTestOpts) => TestActyx;
};

// @public
export type ActyxEvent<E = unknown> = {
    meta: Metadata;
    payload: E;
};

// @public
export const ActyxEvent: {
    ord: Ord<ActyxEvent<unknown>>;
};

// @public
export type ActyxOpts = Readonly<{
    actyxHost?: string;
    actyxPort?: number;
    onConnectionLost?: () => void;
}>;

// @public
export type ActyxTestOpts = Readonly<{
    nodeId?: NodeId;
}>;

// @public
export const allEvents: Tags<unknown>;

// @public
export type AppId = string;

// @public
export const AppId: {
    of: (text: string) => AppId;
    FromString: t.Type<string, string, unknown>;
};

// @public
export type AppManifest = Readonly<{
    appId: string;
    displayName: string;
    version: string;
    signature?: string;
}>;

// @public
export type AutoCappedQuery = {
    lowerBound?: OffsetMap;
    query?: Where<unknown>;
    order?: EventsSortOrder;
};

// @public
export type CancelSubscription = () => void;

// @beta
export type EarliestQuery<E> = {
    query: Where<E>;
    lowerBound?: OffsetMap;
    eventOrder?: EventOrder;
};

// @public
export type EventChunk = {
    events: ActyxEvent[];
    lowerBound: OffsetMap;
    upperBound: OffsetMap;
};

// @public
export interface EventFns {
    currentOffsets: () => Promise<OffsetMap>;
    emit: (events: ReadonlyArray<TaggedEvent>) => PendingEmission;
    readonly nodeId: NodeId;
    observeBestMatch: <E>(query: Where<E>, shouldReplace: (candidate: ActyxEvent<E>, cur: ActyxEvent<E>) => boolean, onReplaced: (event: E, metadata: Metadata) => void) => CancelSubscription;
    // @beta
    observeEarliest: <E>(query: EarliestQuery<E>, onNewEarliest: (event: E, metadata: Metadata) => void) => CancelSubscription;
    // @beta
    observeLatest: <E>(query: EarliestQuery<E>, onNewLatest: (event: E, metadata: Metadata) => void) => CancelSubscription;
    observeUnorderedReduce: <R, E>(query: Where<E>, reduce: (acc: R, event: E, metadata: Metadata) => R, initial: R, onUpdate: (result: R) => void) => CancelSubscription;
    queryAllKnown: (query: AutoCappedQuery) => Promise<EventChunk>;
    queryAllKnownChunked: (query: AutoCappedQuery, chunkSize: number, onChunk: (chunk: EventChunk) => Promise<void> | void, onComplete?: () => void) => CancelSubscription;
    queryKnownRange: (query: RangeQuery) => Promise<ActyxEvent[]>;
    queryKnownRangeChunked: (query: RangeQuery, chunkSize: number, onChunk: (chunk: EventChunk) => Promise<void> | void, onComplete?: () => void) => CancelSubscription;
    subscribe: (query: EventSubscription, onChunk: (chunk: EventChunk) => Promise<void> | void) => CancelSubscription;
    // @alpha
    subscribeMonotonic: <E>(query: MonotonicSubscription<E>, callback: (data: EventsOrTimetravel<E>) => Promise<void> | void) => CancelSubscription;
}

// @public
export type EventKey = t.TypeOf<typeof EventKeyIO>;

// @public
export const EventKey: {
    zero: {
        readonly lamport: number;
        readonly offset: number;
        readonly stream: string;
    };
    ord: Ord<{
        readonly lamport: number;
        readonly offset: number;
        readonly stream: string;
    }>;
    format: (key: EventKey) => string;
};

// @public
export const EventKeyIO: t.ReadonlyC<t.TypeC<{
    lamport: t.Type<number, number, unknown>;
    offset: t.Type<number, number, unknown>;
    stream: t.Type<string, string, unknown>;
}>>;

// @beta
export enum EventOrder {
    Lamport = "lamport",
    Timestamp = "timestamp"
}

// @alpha
export type EventsMsg<E> = Readonly<{
    type: MsgType.events;
    events: ActyxEvent<E>[];
    caughtUp: boolean;
}>;

// @alpha
export type EventsOrTimetravel<E> = StateMsg | EventsMsg<E> | TimeTravelMsg<E>;

// @public
export enum EventsSortOrder {
    Ascending = "asc",
    Descending = "desc",
    StreamAscending = "stream-asc"
}

// @public
export type EventSubscription = {
    lowerBound?: OffsetMap;
    query?: Where<unknown>;
    maxChunkSize?: number;
    maxChunkTimeMs?: number;
};

// @alpha
export type FixedStart = Readonly<{
    from: OffsetMap;
    latestEventKey: EventKey;
    horizon?: EventKey;
}>;

// @public
export type HasOffsetAndStream = {
    offset: number;
    stream: string;
};

// @alpha
export type HasTags = {
    tags: ReadonlyArray<string>;
};

// @public
export const isBoolean: (x: any) => x is boolean;

// @public
export const isNumber: (x: any) => x is number;

// @public
export const isString: (x: any) => x is string;

// @public
export type Lamport = number;

// @public (undocumented)
export const Lamport: {
    of: (value: number) => Lamport;
    zero: number;
    FromNumber: t.Type<number, number, unknown>;
};

// @beta
export type LatestQuery<E> = EarliestQuery<E>;

// @alpha
export type LocalSnapshot<S> = StateWithProvenance<S> & {
    eventKey: EventKey;
    horizon: EventKey | undefined;
    cycle: number;
};

// @public
export type Metadata = Readonly<{
    isLocalEvent: boolean;
    tags: ReadonlyArray<string>;
    timestampMicros: Timestamp;
    timestampAsDate: () => Date;
    lamport: Lamport;
    eventId: string;
    appId: AppId;
    stream: StreamId;
    offset: Offset;
}>;

// @public
export type Milliseconds = number;

// @public
export const Milliseconds: {
    of: (time: number) => Milliseconds;
    fromDate: (date: Date) => Milliseconds;
    zero: number;
    now: (now?: number | undefined) => Milliseconds;
    toSeconds: (value: Milliseconds) => number;
    toTimestamp: (value: Milliseconds) => Timestamp;
    fromSeconds: (value: number) => number;
    fromMinutes: (value: number) => number;
    fromAny: (value: number) => Milliseconds;
    FromNumber: t.Type<number, number, unknown>;
};

// @alpha
export type MonotonicSubscription<E> = {
    sessionId: string;
    query: Where<E>;
    attemptStartFrom?: FixedStart;
};

// @alpha
export enum MsgType {
    // (undocumented)
    events = "events",
    // (undocumented)
    state = "state",
    // (undocumented)
    timetravel = "timetravel"
}

// @public
export type NodeId = string;

// @public
export const NodeId: {
    of: (text: string) => NodeId;
    random: (digits?: number | undefined) => string;
    FromString: t.Type<string, string, unknown>;
    streamNo: (nodeId: NodeId, num: number) => string;
};

// @public
export const noEvents: Where<never>;

// @public
export type Offset = number;

// @public
export const Offset: {
    of: (n: number) => Offset;
    zero: number;
    min: number;
    max: number;
    FromNumber: t.Type<number, number, unknown>;
};

// @public
export type OffsetMap = t.TypeOf<typeof OffsetMapIO>;

// @public
export const OffsetMap: OffsetMapCompanion;

// @public
export type OffsetMapBuilder = Record<string, Offset>;

// @public
export type OffsetMapCompanion = Readonly<{
    empty: OffsetMap;
    isEmpty: (m: OffsetMap) => boolean;
    lookup: (m: OffsetMap, s: string) => Offset;
    lookupOrUndefined: (m: OffsetMap, s: string) => Offset | undefined;
    update: (m: OffsetMapBuilder, ev: HasOffsetAndStream) => OffsetMapBuilder;
}>;

// @public
export const OffsetMapIO: t.ReadonlyC<t.RecordC<t.StringC, t.Type<number, number, unknown>>>;

// @public
export type PendingEmission = {
    subscribe: (whenEmitted: (meta: Metadata[]) => void) => void;
    toPromise: () => Promise<Metadata[]>;
};

// @public
export type RangeQuery = {
    query?: Where<unknown>;
    lowerBound?: OffsetMap;
    upperBound: OffsetMap;
    order?: EventsSortOrder;
};

// @alpha
export type SerializedStateSnap = LocalSnapshot<string>;

// @alpha
export type StateMsg = Readonly<{
    type: MsgType.state;
    snapshot: SerializedStateSnap;
}>;

// @alpha
export type StateWithProvenance<S> = {
    readonly state: S;
    readonly offsets: OffsetMap;
};

// @public
export type StreamId = string;

// @public
export const StreamId: {
    of: (text: string) => StreamId;
    random: () => string;
    FromString: t.Type<string, string, unknown>;
};

// @public
export interface Tag<E> extends Tags<E> {
    withId(name: string): Tags<E>;
}

// @public
export const Tag: <E>(rawTag: string) => Tag<E>;

// @public
export type TaggedEvent = Readonly<{
    tags: string[];
    event: unknown;
}>;

// @public
export interface Tags<E> extends Where<E> {
    and<E1>(tag: Tags<E1>): Tags<Extract<E1, E>>;
    and(tag: string): Tags<E>;
    apply(...events: E[]): ReadonlyArray<TaggedEvent>;
    local(): Tags<E>;
}

// @public
export const Tags: <E>(...requiredTags: string[]) => Tags<E>;

// @public
export type TestActyx = TestEventFns & {
    dispose: () => void;
};

// @public
export type TestEvent = {
    offset: number;
    stream: string;
    timestamp: Timestamp;
    lamport: Lamport;
    tags: ReadonlyArray<string>;
    payload: unknown;
};

// @public
export type TestEventFns = EventFns & {
    directlyPushEvents: (events: ReadonlyArray<TestEvent>) => void;
};

// @public
export type Timestamp = number;

// @public
export const Timestamp: {
    of: (time: number) => Timestamp;
    zero: number;
    maxSafe: number;
    now: (now?: number | undefined) => number;
    format: (timestamp: Timestamp) => string;
    toSeconds: (value: Timestamp) => number;
    toMilliseconds: (value: Timestamp) => Milliseconds;
    toDate: (value: Timestamp) => Date;
    fromDate: (date: Date) => Timestamp;
    fromDays: (value: number) => number;
    fromSeconds: (value: number) => number;
    fromMilliseconds: (value: number) => number;
    min: (...values: Timestamp[]) => number;
    max: (values: Timestamp[]) => number;
    FromNumber: t.Type<number, number, unknown>;
};

// @alpha
export type TimeTravelMsg<E> = Readonly<{
    type: MsgType.timetravel;
    trigger: ActyxEvent<E>;
    high: ActyxEvent<E>;
}>;

// @alpha
export const toEventPredicate: (where: Where<unknown>) => (event: HasTags) => boolean;

// @public
export interface Where<E> {
    readonly _dataType?: E;
    or<E1>(tag: Where<E1>): Where<E1 | E>;
    toString(): string;
}


// (No @packageDocumentation comment for this package)

```

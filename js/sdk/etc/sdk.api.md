## API Report File for "@actyx/sdk"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { Ord } from 'fp-ts/lib/Ord';
import * as t from 'io-ts';

// @public
export type Actyx = EventFns & {
    readonly nodeId: NodeId;
    readonly snapshotStore: SnapshotStore;
    dispose: () => void;
    waitForSync: () => Promise<void>;
    nodeInfo: (maxAgeMillis: number) => Promise<NodeInfo>;
};

// @public
export const Actyx: {
    of: (manifest: AppManifest, opts?: ActyxOpts) => Promise<Actyx>;
    test: (opts?: ActyxTestOpts) => TestActyx;
};

// @public
export type ActyxEvent<E = unknown> = {
    meta: Metadata;
    payload: E;
};

// @public
export const ActyxEvent: {
    ord: Ord<ActyxEvent<unknown>>;
};

// @public
export type ActyxOpts = {
    actyxHost?: string;
    actyxPort?: number;
    onConnectionLost?: () => void;
    onConnectionEstablished?: () => void;
};

// @public
export type ActyxTestOpts = Readonly<{
    nodeId?: NodeId;
    timeInjector?: TimeInjector;
}>;

// @public
export const allEvents: Tags<unknown>;

// @public
export type AppId = string;

// @public
export const AppId: {
    of: (text: string) => AppId;
};

// @public
export type AppManifest = {
    appId: string;
    displayName: string;
    version: string;
    signature?: string;
};

// @beta
export type AqlDiagnosticMessage = {
    type: 'diagnostic';
    severity: string;
    message: string;
};

// @beta
export type AqlEventMessage = {
    type: 'event';
    payload: unknown;
    meta: Metadata;
};

// @beta
export type AqlFutureCompat = {
    type: Exclude<'event' | 'offsets' | 'diagnostic', string>;
    payload: unknown;
    meta: Record<string, unknown>;
};

// @beta
export type AqlOffsetsMsg = {
    type: 'offsets';
    offsets: OffsetMap;
};

// @beta
export type AqlQuery = string | {
    query: string;
    order?: EventsSortOrder;
};

// @beta
export type AqlResponse = AqlEventMessage | AqlOffsetsMsg | AqlDiagnosticMessage | AqlFutureCompat;

// @public
export type AutoCappedQuery = {
    lowerBound?: OffsetMap;
    query?: Where<unknown>;
    order?: EventsSortOrder;
    horizon?: string;
};

// @public
export type CancelSubscription = () => void;

// @beta
export type EarliestQuery<E> = {
    query: Where<E>;
    lowerBound?: OffsetMap;
    eventOrder?: EventOrder;
};

// @public
export type EventChunk = {
    events: ActyxEvent[];
    lowerBound: OffsetMap;
    upperBound: OffsetMap;
};

// @public
export interface EventFns {
    // @deprecated
    emit: (events: ReadonlyArray<TaggedEvent>) => PendingEmission;
    observeBestMatch: <E>(query: Where<E>, shouldReplace: (candidate: ActyxEvent<E>, cur: ActyxEvent<E>) => boolean, onReplaced: (event: E, metadata: Metadata) => void, onError?: (err: unknown) => void) => CancelSubscription;
    // @beta
    observeEarliest: <E>(query: EarliestQuery<E>, onNewEarliest: (event: E, metadata: Metadata) => void, onError?: (err: unknown) => void) => CancelSubscription;
    // @beta
    observeLatest: <E>(query: EarliestQuery<E>, onNewLatest: (event: E, metadata: Metadata) => void, onError?: (err: unknown) => void) => CancelSubscription;
    observeUnorderedReduce: <R, E>(query: Where<E>, reduce: (acc: R, event: E, metadata: Metadata) => R, initial: R, onUpdate: (result: R) => void, onError?: (err: unknown) => void) => CancelSubscription;
    offsets: () => Promise<OffsetsResponse>;
    present: () => Promise<OffsetMap>;
    publish(event: TaggedEvent): Promise<Metadata>;
    // (undocumented)
    publish(events: ReadonlyArray<TaggedEvent>): Promise<Metadata[]>;
    queryAllKnown: (query: AutoCappedQuery) => Promise<EventChunk>;
    queryAllKnownChunked: (query: AutoCappedQuery, chunkSize: number, onChunk: (chunk: EventChunk) => Promise<void> | void, onComplete?: OnCompleteOrErr) => CancelSubscription;
    // @beta
    queryAql: (query: AqlQuery) => Promise<AqlResponse[]>;
    // @beta
    queryAqlChunked: (query: AqlQuery, chunkSize: number, onChunk: (chunk: AqlResponse[]) => Promise<void> | void, onCompleteOrError: OnCompleteOrErr) => CancelSubscription;
    queryKnownRange: (query: RangeQuery) => Promise<ActyxEvent[]>;
    queryKnownRangeChunked: (query: RangeQuery, chunkSize: number, onChunk: (chunk: EventChunk) => Promise<void> | void, onComplete?: OnCompleteOrErr) => CancelSubscription;
    subscribe: (query: EventSubscription, onEvent: (e: ActyxEvent) => Promise<void> | void, onError?: (err: unknown) => void) => CancelSubscription;
    // @beta
    subscribeAql: (query: AqlQuery, onResponse: (r: AqlResponse) => Promise<void> | void, onError?: (err: unknown) => void, lowerBound?: OffsetMap) => CancelSubscription;
    subscribeChunked: (query: EventSubscription, chunkConfig: {
        maxChunkSize?: number;
        maxChunkTimeMs?: number;
    }, onChunk: (chunk: EventChunk) => Promise<void> | void, onError?: (err: unknown) => void) => CancelSubscription;
    // @alpha
    subscribeMonotonic: <E>(query: MonotonicSubscription<E>, callback: (data: EventsOrTimetravel<E>) => Promise<void> | void, onCompleteOrErr?: OnCompleteOrErr) => CancelSubscription;
}

// @public
export type EventKey = Readonly<{
    lamport: Lamport;
    offset: Offset;
    stream: StreamId;
}>;

// @public
export const EventKey: {
    zero: Readonly<{
        lamport: Lamport;
        offset: Offset;
        stream: StreamId;
    }>;
    ord: Ord<Readonly<{
        lamport: Lamport;
        offset: Offset;
        stream: StreamId;
    }>>;
    format: (key: EventKey) => string;
};

// @beta
export enum EventOrder {
    Lamport = "lamport",
    Timestamp = "timestamp"
}

// @alpha
export type EventsMsg<E> = Readonly<{
    type: MsgType.events;
    events: ActyxEvent<E>[];
    caughtUp: boolean;
}>;

// @alpha
export type EventsOrTimetravel<E> = StateMsg | EventsMsg<E> | TimeTravelMsg<E>;

// @public
export enum EventsSortOrder {
    Ascending = "asc",
    Descending = "desc",
    StreamAscending = "stream-asc"
}

// @public
export type EventSubscription = {
    lowerBound?: OffsetMap;
    query?: Where<unknown>;
};

// @alpha
export type FixedStart = Readonly<{
    from: OffsetMap;
    latestEventKey: EventKey;
    horizon?: EventKey;
}>;

// @public
export type HasOffsetAndStream = {
    offset: number;
    stream: string;
};

// @alpha
export type HasTags = {
    tags: ReadonlyArray<string>;
};

// @beta
export type InvalidateAllSnapshots = () => Promise<void>;

// @beta
export type InvalidateSnapshots = (semantics: string, name: string, key: EventKey) => Promise<void>;

// @public
export const isBoolean: (x: any) => x is boolean;

// @public
export const isNumber: (x: any) => x is number;

// @public
export const isString: (x: any) => x is string;

// @public
export type Lamport = number;

// @public (undocumented)
export const Lamport: {
    of: (value: number) => Lamport;
    zero: number;
};

// @beta
export type LatestQuery<E> = EarliestQuery<E>;

// @beta
export type LocalSnapshot<S> = StateWithProvenance<S> & {
    eventKey: EventKey;
    horizon: EventKey | undefined;
    cycle: number;
};

// @beta
export type LocalSnapshotFromIndex = LocalSnapshot<string>;

// @public
export type Metadata = Readonly<{
    isLocalEvent: boolean;
    tags: ReadonlyArray<string>;
    timestampMicros: Timestamp;
    timestampAsDate: () => Date;
    lamport: Lamport;
    eventId: string;
    appId: AppId;
    stream: StreamId;
    offset: Offset;
}>;

// @public
export type Milliseconds = number;

// @public
export const Milliseconds: {
    of: (time: number) => Milliseconds;
    fromDate: (date: Date) => Milliseconds;
    zero: number;
    now: (now?: number | undefined) => Milliseconds;
    toSeconds: (value: Milliseconds) => number;
    toTimestamp: (value: Milliseconds) => Timestamp;
    fromSeconds: (value: number) => number;
    fromMinutes: (value: number) => number;
    fromAny: (value: number) => Milliseconds;
};

// @alpha
export type MonotonicSubscription<E> = {
    sessionId: string;
    query: Where<E>;
    attemptStartFrom: FixedStart;
};

// @alpha
export enum MsgType {
    // (undocumented)
    events = "events",
    // (undocumented)
    state = "state",
    // (undocumented)
    timetravel = "timetravel"
}

// @public
export type NodeId = string;

// @public
export const NodeId: {
    of: (text: string) => NodeId;
    random: (digits?: number | undefined) => string;
    streamNo: (nodeId: NodeId, num: number) => string;
};

// @public
export class NodeInfo {
    // Warning: (ae-forgotten-export) The symbol "NodeInfo" needs to be exported by the entry point index.d.ts
    constructor(io: NodeInfo_2);
    // (undocumented)
    connectedNodes(): number;
    // (undocumented)
    isAtLeastVersion(version: string): boolean;
    // (undocumented)
    longVersion(): string;
    // (undocumented)
    semVer(): string;
    // (undocumented)
    uptimeMillis(): number;
}

// @public
export type Offset = number;

// @public
export const Offset: {
    of: (n: number) => Offset;
    zero: number;
    min: number;
    max: number;
};

// @public
export type OffsetMap = Record<StreamId, Offset>;

// @public
export const OffsetMap: OffsetMapCompanion;

// @public
export type OffsetMapBuilder = Record<string, Offset>;

// @public
export type OffsetMapCompanion = Readonly<{
    empty: OffsetMap;
    isEmpty: (m: OffsetMap) => boolean;
    lookup: (m: OffsetMap, s: string) => Offset;
    lookupOrUndefined: (m: OffsetMap, s: string) => Offset | undefined;
    update: (m: OffsetMapBuilder, ev: HasOffsetAndStream) => OffsetMapBuilder;
}>;

// @public
export type OffsetsResponse = {
    present: OffsetMap;
    toReplicate: Record<StreamId, number>;
};

// @public
export type OnCompleteOrErr = (err?: unknown) => void;

// @public
export type PendingEmission = {
    subscribe: (whenEmitted: (meta: Metadata[]) => void) => void;
    toPromise: () => Promise<Metadata[]>;
};

// @public
export type RangeQuery = {
    query?: Where<unknown>;
    lowerBound?: OffsetMap;
    upperBound: OffsetMap;
    order?: EventsSortOrder;
    horizon?: string;
};

// @beta
export type RetrieveSnapshot = (semantics: string, name: string, version: number) => Promise<LocalSnapshotFromIndex | undefined>;

// @beta
export type SerializedStateSnap = LocalSnapshot<string>;

// @beta
export interface SnapshotStore {
    invalidateAllSnapshots: InvalidateAllSnapshots;
    invalidateSnapshots: InvalidateSnapshots;
    retrieveSnapshot: RetrieveSnapshot;
    storeSnapshot: StoreSnapshot;
}

// @beta
export const SnapshotStore: {
    noop: SnapshotStore;
    inMem: () => SnapshotStore;
};

// @alpha
export type StateMsg = Readonly<{
    type: MsgType.state;
    snapshot: SerializedStateSnap;
}>;

// @beta
export type StateWithProvenance<S> = {
    readonly state: S;
    readonly offsets: OffsetMap;
};

// @beta
export type StoreSnapshot = (semantics: string, name: string, key: EventKey, offsets: OffsetMap, horizon: EventKey | undefined, cycle: number, version: number, tag: string, serializedBlob: string) => Promise<boolean>;

// @public
export type StreamId = string;

// @public
export const StreamId: {
    of: (text: string) => StreamId;
    random: () => string;
};

// @public
export interface Tag<E = unknown> extends Tags<E> {
    id(name: string): Tags<unknown>;
    withId(name: string): Tags<E>;
}

// @public
export const Tag: <E = unknown>(rawTagString: string, extractId?: ((e: E) => string) | undefined) => Tag<E>;

// @public
export type TaggedEvent = Readonly<{
    tags: string[];
    event: unknown;
}>;

// @public
export interface TaggedTypedEvent<E = unknown> extends TaggedEvent {
    // (undocumented)
    readonly event: E;
    // (undocumented)
    readonly tags: string[];
    // (undocumented)
    withTags<E1>(tags: Tags<E1> & (E extends E1 ? unknown : never)): TaggedTypedEvent<E>;
}

// @public
export interface Tags<E = unknown> extends Where<E> {
    and<E1 = unknown>(tag: Tags<E1>): Tags<E1 & E>;
    and(tag: string): Tags<E>;
    apply(event: E): TaggedEvent;
    apply(...events: E[]): ReadonlyArray<TaggedEvent>;
    applyTyped<E1 extends E>(event: E1): TaggedTypedEvent<E1>;
    local(): Tags<E>;
}

// @public
export const Tags: <E = unknown>(...requiredTags: string[]) => Tags<E>;

// @public
export type TestActyx = TestEventFns & {
    readonly nodeId: NodeId;
    readonly snapshotStore: SnapshotStore;
    dispose: () => void;
    waitForSync: () => Promise<void>;
};

// @public
export type TestEvent = {
    offset: number;
    stream: string;
    timestamp: Timestamp;
    lamport: Lamport;
    tags: ReadonlyArray<string>;
    payload: unknown;
};

// @public
export type TestEventFns = EventFns & {
    directlyPushEvents: (events: ReadonlyArray<TestEvent>) => void;
};

// @beta
export type TimeInjector = (tags: ReadonlyArray<string>, events: unknown) => Timestamp;

// @public
export type Timestamp = number;

// @public
export const Timestamp: {
    of: (time: number) => Timestamp;
    zero: number;
    maxSafe: number;
    now: (now?: number | undefined) => number;
    format: (timestamp: Timestamp) => string;
    toSeconds: (value: Timestamp) => number;
    toMilliseconds: (value: Timestamp) => Milliseconds;
    toDate: (value: Timestamp) => Date;
    fromDate: (date: Date) => Timestamp;
    fromDays: (value: number) => number;
    fromSeconds: (value: number) => number;
    fromMilliseconds: (value: number) => number;
    min: (...values: Timestamp[]) => number;
    max: (values: Timestamp[]) => number;
};

// @alpha
export type TimeTravelMsg<E> = Readonly<{
    type: MsgType.timetravel;
    trigger: EventKey;
}>;

// @alpha
export const toEventPredicate: (where: Where<unknown>) => (event: HasTags) => boolean;

// @public
export interface Where<E> {
    readonly _dataType?: E;
    or<E1>(tag: Where<E1>): Where<E1 | E>;
    toString(): string;
}

// (No @packageDocumentation comment for this package)

```

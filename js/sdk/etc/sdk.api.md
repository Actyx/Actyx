## API Report File for "@actyx/sdk"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { Ord } from 'fp-ts/lib/Ord';
import * as t from 'io-ts';

// @public
export type ActyxEvent<E = unknown> = {
    meta: Metadata;
    payload: E;
};

// @public
export const allEvents: Tags<unknown>;

// @public
export type AutoCappedQuery = {
    lowerBound?: OffsetMap;
    query?: Where<unknown>;
    order?: 'Asc' | 'Desc';
};

// @public
export type CancelSubscription = () => void;

// @beta
export type EarliestQuery<E> = {
    query: Where<E>;
    lowerBound?: OffsetMap;
    eventOrder?: EventOrder;
};

// @public
export type EventChunk = {
    events: ActyxEvent[];
    lowerBound: OffsetMap;
    upperBound: OffsetMap;
};

// @public
export interface EventFns {
    currentOffsets: () => Promise<OffsetMap>;
    emit: (events: ReadonlyArray<TaggedEvent>) => PendingEmission;
    observeBestMatch: <E>(query: Where<E>, shouldReplace: (candidate: ActyxEvent<E>, cur: ActyxEvent<E>) => boolean, onReplaced: (event: E, metadata: Metadata) => void) => CancelSubscription;
    // @beta
    observeEarliest: <E>(query: EarliestQuery<E>, onNewEarliest: (event: E, metadata: Metadata) => void) => CancelSubscription;
    // @beta
    observeLatest: <E>(query: EarliestQuery<E>, onNewLatest: (event: E, metadata: Metadata) => void) => CancelSubscription;
    observeUnorderedReduce: <R, E>(query: Where<E>, reduce: (acc: R, event: E, metadata: Metadata) => R, initial: R, onUpdate: (result: R) => void) => CancelSubscription;
    queryAllKnown: (query: AutoCappedQuery) => Promise<EventChunk>;
    queryAllKnownChunked: (query: AutoCappedQuery, chunkSize: number, onChunk: (chunk: EventChunk) => Promise<void> | void) => Promise<OffsetMap>;
    queryKnownRange: (query: RangeQuery) => Promise<ActyxEvent[]>;
    queryKnownRangeChunked: (query: RangeQuery, chunkSize: number, onChunk: (chunk: EventChunk) => Promise<void> | void) => Promise<void>;
    subscribe: (query: EventSubscription, onChunk: (chunk: EventChunk) => Promise<void> | void) => CancelSubscription;
}

// @public (undocumented)
export type EventKey = t.TypeOf<typeof EventKeyIO>;

// @public (undocumented)
export const EventKey: {
    zero: {
        readonly lamport: number;
        readonly offset: number;
        readonly stream: string;
    };
    ord: Ord<{
        readonly lamport: number;
        readonly offset: number;
        readonly stream: string;
    }>;
    format: (key: EventKey) => string;
};

// @public (undocumented)
export const EventKeyIO: t.ReadonlyC<t.TypeC<{
    lamport: t.Type<number, number, unknown>;
    offset: t.Type<number, number, unknown>;
    stream: t.Type<string, string, unknown>;
}>>;

// @beta
export enum EventOrder {
    Lamport = "lamport",
    Timestamp = "timestamp"
}

// @public
export type EventSubscription = {
    lowerBound?: OffsetMap;
    query?: Where<unknown>;
    maxChunkSize?: number;
};

// @public (undocumented)
export type HasMetadata = Readonly<{
    timestamp: Timestamp;
    lamport: Lamport;
    stream: StreamId;
    tags: ReadonlyArray<string>;
}>;

// @public (undocumented)
export type HasOffsetAndStream = {
    offset: number;
    stream: string;
};

// @public (undocumented)
export type HasTags = {
    tags: ReadonlyArray<string>;
};

// @public
export const isBoolean: (x: any) => x is boolean;

// @public
export const isNumber: (x: any) => x is number;

// @public
export const isString: (x: any) => x is string;

// @public
export type Lamport = number;

// @public (undocumented)
export const Lamport: {
    of: (value: number) => Lamport;
    zero: number;
    FromNumber: t.Type<number, number, unknown>;
};

// @beta
export type LatestQuery<E> = EarliestQuery<E>;

// @public (undocumented)
export const maxLamportLength: number;

// @public
export type Metadata = Readonly<{
    isLocalEvent: boolean;
    tags: ReadonlyArray<string>;
    timestampMicros: Timestamp;
    timestampAsDate: () => Date;
    lamport: Lamport;
    eventId: string;
}>;

// @public
export type Milliseconds = number;

// @public
export const Milliseconds: {
    of: (time: number) => Milliseconds;
    fromDate: (date: Date) => Milliseconds;
    zero: number;
    now: (now?: number | undefined) => Milliseconds;
    toSeconds: (value: Milliseconds) => number;
    toTimestamp: (value: Milliseconds) => Timestamp;
    fromSeconds: (value: number) => number;
    fromMinutes: (value: number) => number;
    fromAny: (value: number) => Milliseconds;
    FromNumber: t.Type<number, number, unknown>;
};

// @public
export type NodeId = string;

// @public
export const NodeId: {
    of: (text: string) => NodeId;
    random: (digits?: number | undefined) => string;
    FromString: t.Type<string, string, unknown>;
    streamNo: (nodeId: NodeId, num: number) => string;
};

// @public
export const noEvents: Where<never>;

// @public (undocumented)
export type Offset = number;

// @public (undocumented)
export const Offset: {
    of: (psn: number) => Offset;
    zero: number;
    min: number;
    max: number;
    FromNumber: t.Type<number, number, unknown>;
};

// @public
export type OffsetMap = t.TypeOf<typeof OffsetMapIO>;

// @public (undocumented)
export const OffsetMap: OffsetMapCompanion;

// @public
export type OffsetMapBuilder = Record<string, Offset>;

// @public (undocumented)
export type OffsetMapCompanion = Readonly<{
    empty: OffsetMap;
    isEmpty: (m: OffsetMap) => boolean;
    lookup: (m: OffsetMap, s: string) => Offset;
    lookupOrUndefined: (m: OffsetMap, s: string) => Offset | undefined;
    update: (m: OffsetMapBuilder, ev: HasOffsetAndStream) => OffsetMapBuilder;
}>;

// @public (undocumented)
export const OffsetMapIO: t.ReadonlyC<t.RecordC<t.StringC, t.Type<number, number, unknown>>>;

// @public
export type PendingEmission = {
    subscribe: (whenEmitted: () => void) => void;
    toPromise: () => Promise<void>;
};

// @public (undocumented)
export const randomBase58: (digits: number) => string;

// @public
export type RangeQuery = {
    query?: Where<unknown>;
    lowerBound?: OffsetMap;
    upperBound: OffsetMap;
    order?: 'Asc' | 'Desc';
};

// @public
export type StreamId = string;

// @public
export const StreamId: {
    of: (text: string) => StreamId;
    random: () => string;
    FromString: t.Type<string, string, unknown>;
};

// @public
export interface Tag<E> extends Tags<E> {
    // (undocumented)
    readonly rawTag: string;
    withId(name: string): Tags<E>;
}

// @public
export const Tag: <E>(rawTag: string) => Tag<E>;

// @public
export type TaggedEvent = Readonly<{
    tags: string[];
    event: unknown;
}>;

// @public
export interface Tags<E> extends Where<E> {
    and<E1>(tag: Tags<E1>): Tags<Extract<E1, E>>;
    and(tag: string): Tags<E>;
    local(): Tags<E>;
    readonly rawTags: ReadonlyArray<string>;
}

// @public
export const Tags: <E>(...requiredTags: string[]) => Tags<E>;

// @public (undocumented)
export type TagSubscription = Readonly<{
    tags: ReadonlyArray<string>;
    local: boolean;
}>;

// @public
export type Timestamp = number;

// @public
export const Timestamp: {
    of: (time: number) => Timestamp;
    zero: number;
    maxSafe: number;
    now: (now?: number | undefined) => number;
    format: (timestamp: Timestamp) => string;
    toSeconds: (value: Timestamp) => number;
    toMilliseconds: (value: Timestamp) => Milliseconds;
    toDate: (value: Timestamp) => Date;
    fromDate: (date: Date) => Timestamp;
    fromDays: (value: number) => number;
    fromSeconds: (value: number) => number;
    fromMilliseconds: (value: number) => number;
    min: (...values: Timestamp[]) => number;
    max: (values: Timestamp[]) => number;
    FromNumber: t.Type<number, number, unknown>;
};

// @alpha
export const toEventPredicate: (where: Where<unknown>) => (event: HasTags) => boolean;

// @public (undocumented)
export const toMetadata: (sourceId: string) => (ev: HasMetadata) => Metadata;

// @public
export interface Where<E> {
    readonly _dataType?: E;
    or<E1>(tag: Where<E1>): Where<E1 | E>;
    toString(): string;
}


// (No @packageDocumentation comment for this package)

```
